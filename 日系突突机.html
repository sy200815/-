<!DOCTYPE html>
<html lang="ja-JP">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chat with Xingzhi</title>
    <style>
        /* --- Google Fonts --- */
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@300;400;500&family=Pacifico&family=Cubic+11&display=swap');

        /* --- Global Styles & Variables --- */
        :root {
            --font-main: 'Cubic 11', 'Noto Sans JP', sans-serif;
            --font-ui: 'Cubic 11', 'Noto Sans JP', sans-serif; /* UIフォントも統一 */
            --font-logo: 'Pacifico', cursive;
            
            --bg-color: #fcefee;
            --chat-bg-color: rgba(255, 255, 255, 0.85);
            --header-bg-color: rgba(255, 255, 255, 0.95);
            --input-bg-color: #ffffff;
            --text-color: #5c5c5c;
            --text-light-color: #a0a0a0;
            --accent-color: #ff8fab;
            --accent-dark-color: #f87197;
            --border-color: #fde2e8;
            --delete-color: #ff6b6b;
            --success-color: #4CAF50;

            /* Bubble Themes */
            --theme1-ai-bg: #ffffff; --theme1-ai-text: #333333;
            --theme1-user-bg: #333333; --theme1-user-text: #ffffff;
            --theme2-ai-bg: #333333; --theme2-ai-text: #ffffff;
            --theme2-user-bg: #ffffff; --theme2-user-text: #333333;
            --theme3-ai-bg: #f0f0f0; --theme3-ai-text: #555555;
            --theme3-user-bg: #87ceeb; --theme3-user-text: #ffffff;
            --theme4-ai-bg: #f0f0f0; --theme4-ai-text: #555555;
            --theme4-user-bg: #98d8a8; --theme4-user-text: #ffffff;
            --theme5-ai-bg: #ffffff; --theme5-ai-text: #444444;
            --theme5-user-bg: #ffe4f1; --theme5-user-text: #c2185b;

            --ai-bubble-bg: var(--theme1-ai-bg);
            --ai-bubble-text: var(--theme1-ai-text);
            --user-bubble-bg: var(--theme1-user-bg);
            --user-bubble-text: var(--theme1-user-text);
        }

        /* --- Base & Layout --- */
        html, body { height: 100%; overflow: hidden; }
        body {
            font-family: var(--font-main);
            margin: 0; padding: 0;
            background-color: var(--bg-color);
            background-image: url('data:image/svg+xml,%3Csvg width="60" height="60" viewBox="0 0 60 60" xmlns="http://www.w3.org/2000/svg"%3E%3Cg fill="none" fill-rule="evenodd"%3E%3Cg fill="%23f7d3e1" fill-opacity="0.4"%3E%3Cpath d="M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z"/%3E%3C/g%3E%3C/g%3E%3C/svg%3E');
            color: var(--text-color);
            transition: background-color 0.5s ease;
        }

        #chat-container {
            display: flex; flex-direction: column; height: 100%; max-width: 800px; margin: 0 auto;
            background-color: var(--chat-bg-color); backdrop-filter: blur(10px); box-shadow: 0 0 30px rgba(255, 143, 171, 0.15);
            transition: background-color 0.5s ease;
        }

        #chat-header {
            display: flex; justify-content: space-between; align-items: center; padding: 10px 15px;
            background-color: var(--header-bg-color); border-bottom: 1px solid var(--border-color); backdrop-filter: blur(5px); z-index: 10;
            flex-shrink: 0;
        }
        #chat-manager-btn { background: none; border: none; cursor: pointer; padding: 5px; }
        #chat-manager-btn svg { width: 26px; height: 26px; fill: var(--accent-color); transition: transform 0.3s ease, fill 0.3s ease; }
        #chat-manager-btn:hover svg { fill: var(--accent-dark-color); transform: scale(1.1); }
        
        #header-avatar {
            width: 40px; height: 40px; border-radius: 8px; object-fit: cover;
            border: 2px solid var(--border-color); cursor: pointer; transition: transform 0.2s ease;
        }
        #header-avatar:hover { transform: scale(1.1); }
        #chat-name-header { flex-grow: 1; text-align: center; font-size: 1.2em; font-weight: 500; color: var(--accent-dark-color); padding: 5px; border-radius: 5px; transition: background-color 0.2s; }
        #chat-name-header:focus { outline: 1px solid var(--accent-color); background-color: rgba(255, 143, 171, 0.1); }
        #settings-btn { background: none; border: none; cursor: pointer; padding: 5px; }
        #settings-btn svg { width: 24px; height: 24px; fill: var(--accent-color); transition: transform 0.3s ease, fill 0.3s ease; }
        #settings-btn:hover svg { transform: rotate(45deg); fill: var(--accent-dark-color); }
        
        #messages { flex-grow: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 5px; }
        #messages::-webkit-scrollbar { width: 6px; }
        #messages::-webkit-scrollbar-track { background: transparent; }
        #messages::-webkit-scrollbar-thumb { background-color: var(--accent-color); border-radius: 10px; }

        /* --- Message Bubbles --- */
        .message { display: flex; align-items: flex-end; gap: 10px; max-width: 80%; cursor: pointer; margin-bottom: 10px; }
        .message.user { align-self: flex-end; flex-direction: row-reverse; }
        .message.ai { align-self: flex-start; }
        .message .sender-name { font-size: 0.75em; color: #999; margin-bottom: 4px; padding: 0 5px; display: none; }
        .message.group-chat.ai .sender-name { display: block; }
        .message.system { align-self: center; background: #e0e0e0; color: #757575; font-size: 0.8em; padding: 4px 10px; border-radius: 10px; max-width: none; cursor: default; }
        .message.system .avatar, .message.system .timestamp { display: none; }
        .avatar { width: 40px; height: 40px; border-radius: 8px; object-fit: cover; border: 2px solid var(--border-color); flex-shrink: 0; }
        .message-content { display: flex; flex-direction: column; }
        .message.user .message-content { align-items: flex-end; }
        .message.ai .message-content { align-items: flex-start; }
        .bubble { padding: 10px 15px; border-radius: 18px; position: relative; box-shadow: 0 2px 5px rgba(0,0,0,0.05); word-wrap: break-word; max-width: 100%; transition: transform 0.2s ease, border 0.2s ease, opacity 0.2s ease; }
        .message.ai .bubble { background-color: var(--ai-bubble-bg); color: var(--ai-bubble-text); border-bottom-left-radius: 4px; }
        .message.user .bubble { background-color: var(--user-bubble-bg); color: var(--user-bubble-text); border-bottom-right-radius: 4px; }
        .bubble p { margin: 0; }
        .timestamp { font-size: 0.7em; color: var(--text-light-color); margin-top: 5px; padding: 0 5px; }
        
        /* Multi-select Mode */
        .multi-select-mode .message:not(.selected):not(.system) { opacity: 0.6; }
        .multi-select-mode .message.selected .bubble { transform: scale(1.03); border: 2px solid var(--accent-dark-color); }

        /* Typing Indicator */
        .typing-indicator { align-items: center; gap: 8px; font-size: 0.9em; font-style: italic; color: #aaa; }
        .typing-indicator .dot { width: 6px; height: 6px; background-color: #ccc; border-radius: 50%; animation: typing 1.4s infinite; }
        .typing-indicator .dot:nth-child(1) { animation-delay: 0.2s; }
        .typing-indicator .dot:nth-child(2) { animation-delay: 0.4s; }
        @keyframes typing { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-4px); } }

        /* --- Input Area & Action Panel --- */
        #bottom-panel { position: relative; flex-shrink: 0; background: var(--header-bg-color); }
        #input-area { display: flex; align-items: flex-end; padding: 10px 15px; border-top: 1px solid var(--border-color); transition: opacity 0.3s ease, visibility 0.3s ease; }
        #action-btn { background: none; border: none; cursor: pointer; padding: 5px; margin-right: 5px; align-self: center; flex-shrink: 0;}
        #action-btn svg { width: 28px; height: 28px; fill: var(--accent-color); transition: transform 0.3s ease, fill 0.2s; }
        #action-btn:hover svg { fill: var(--accent-dark-color); }
        #message-input { flex-grow: 1; border: 1px solid var(--border-color); border-radius: 20px; padding: 10px 15px; font-size: 1em; font-family: var(--font-main); margin-right: 10px; resize: none; transition: border-color 0.3s ease, box-shadow 0.3s ease; max-height: 100px; overflow-y: auto; }
        #message-input:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 5px var(--accent-color); }
        #send-btn { background-color: var(--accent-color); border: none; border-radius: 50%; width: 44px; height: 44px; cursor: pointer; display: flex; justify-content: center; align-items: center; transition: background-color 0.3s ease, transform 0.2s ease; flex-shrink: 0; }
        #send-btn:hover { background-color: var(--accent-dark-color); transform: scale(1.1); }
        #send-btn:disabled { background-color: #f8c3d1; cursor: not-allowed; transform: scale(1); }
        #send-btn svg { width: 20px; height: 20px; fill: white; }

        #action-panel { display: grid; grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); gap: 15px; padding-top: 0; padding-bottom: 0; padding-left: 20px; padding-right: 20px; border-top: 1px solid var(--border-color); max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; }
        #action-panel.show { max-height: 300px; padding-top: 20px; padding-bottom: 20px; }
        .action-item { display: flex; flex-direction: column; align-items: center; cursor: pointer; font-family: var(--font-ui); font-size: 0.8em; color: var(--text-color); }
        .action-item-icon { width: 50px; height: 50px; background-color: #fff; border: 1px solid var(--border-color); border-radius: 12px; display: flex; justify-content: center; align-items: center; margin-bottom: 5px; transition: all 0.2s ease; }
        .action-item:hover .action-item-icon { transform: translateY(-3px); box-shadow: 0 4px 10px rgba(255, 143, 171, 0.3); }
        .action-item-icon svg { width: 24px; height: 24px; fill: var(--accent-color); }

        /* --- Feature-Specific Bubbles --- */
        .bubble.message-image, .bubble.message-sticker { padding: 5px; background: transparent; box-shadow: none; }
        .bubble-image-content { max-width: 250px; max-height: 250px; border-radius: 15px; object-fit: cover; display: block; border: 1px solid var(--border-color); }
        
        .bubble.message-text-image { display: flex; flex-direction: column; gap: 8px; }
        .message.ai .bubble.message-text-image { background-color: var(--ai-bubble-bg); color: var(--ai-bubble-text); }
        .message.user .bubble.message-text-image { background-color: var(--user-bubble-bg); color: var(--user-bubble-text); }
        .text-image-header { display: flex; align-items: center; gap: 8px; font-size: 0.9em; opacity: 0.8;}
        .text-image-header svg { width: 18px; height: 18px; fill: currentColor; }
        .text-image-description { border-left: 2px solid var(--accent-color); padding-left: 10px; font-family: var(--font-ui); white-space: pre-wrap; }

        .bubble.message-voice { display: flex; align-items: center; gap: 10px; }
        .message.ai .bubble.message-voice { background: var(--ai-bubble-bg); color: var(--ai-bubble-text); }
        .message.user .bubble.message-voice { background: var(--user-bubble-bg); color: var(--user-bubble-text); }
        .voice-icon svg { width: 20px; height: 20px; fill: currentColor; }
        .voice-duration { font-family: var(--font-ui); }

        .bubble.message-transfer { padding: 0; border-radius: 12px; overflow: hidden; background: #ff7675; color: white; width: 240px; box-shadow: 0 4px 10px rgba(255, 118, 117, 0.4); position: relative; cursor: default; }
        .message.ai .bubble.message-transfer { cursor: pointer; }
        .transfer-cover { width: 100%; height: 110px; object-fit: cover; display: block; }
        .transfer-info { padding: 10px 15px; }
        .transfer-amount { font-size: 1.4em; font-weight: bold; font-family: var(--font-ui); }
        .transfer-memo { font-size: 0.9em; opacity: 0.9; margin-top: 5px; }
        .transfer-footer { font-size: 0.7em; opacity: 0.8; padding: 5px 15px; background: rgba(0,0,0,0.1); }
        .transfer-acknowledged { position: absolute; top:0; left:0; right:0; bottom:0; background: rgba(0,0,0,0.3); backdrop-filter: blur(2px); display:flex; justify-content:center; align-items:center; color:white; font-family:var(--font-ui); font-size:1.1em; }
        
        /* Poll Bubble */
        .bubble.message-poll { background: #fff; border: 1px solid var(--border-color); padding: 15px; color: var(--text-color); width: 280px; }
        .poll-question { font-weight: 500; margin-bottom: 15px; font-size: 1.05em; color: var(--accent-dark-color); }
        .poll-option { margin-bottom: 10px; }
        .poll-option-label { display: block; margin-bottom: 5px; font-size: 0.9em; }
        .poll-progress-bar { background: #f0f0f0; border-radius: 5px; overflow: hidden; height: 20px; position: relative; }
        .poll-progress-fill { background: linear-gradient(45deg, var(--accent-color), #ffb8ca); height: 100%; border-radius: 5px; transition: width 0.5s ease; display: flex; align-items: center; justify-content: flex-end; padding-right: 5px; box-sizing: border-box; }
        .poll-percentage { color: white; font-size: 0.8em; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.2); }
        .poll-voters { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 5px; padding-left: 2px; }
        .poll-voter-avatar { width: 20px; height: 20px; border-radius: 50%; object-fit: cover; border: 1px solid white; box-shadow: 0 0 2px rgba(0,0,0,0.2); }
        .poll-vote-btn { background: #f7f7f7; border: 1px solid #ddd; border-radius: 8px; padding: 8px 12px; cursor: pointer; font-size: 0.9em; transition: all 0.2s ease; display: block; width: 100%; margin-top: 8px; text-align: center; }
        .poll-vote-btn:hover { background: #eee; border-color: #ccc; }
        .poll-vote-btn.voted, .poll-vote-btn:disabled { background: var(--accent-color); color: white; border-color: var(--accent-color); cursor: not-allowed; opacity: 0.7; }

        /* --- Generic & Specific Modals --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); backdrop-filter: blur(5px); display: none; justify-content: center; align-items: center; z-index: 1000; animation: fadeIn 0.3s ease; }
        .modal-overlay.show { display: flex; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
        .modal-overlay.hiding { animation: fadeOut 0.3s ease forwards; }

        .feature-modal-content { font-family: var(--font-ui); background: #fff; padding: 25px 35px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); width: 90%; max-width: 450px; animation: slideIn 0.3s ease-out; }
        @keyframes slideIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        @keyframes slideOut { from { transform: translateY(0); opacity: 1; } to { transform: translateY(20px); opacity: 0; } }
        .modal-overlay.hiding .feature-modal-content { animation: slideOut 0.3s ease-out forwards; }
        
        .feature-modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .feature-modal-header h3 { margin: 0; font-family: var(--font-logo); color: var(--accent-dark-color); font-size: 1.8em; }
        .feature-modal-close { background: none; border: none; font-size: 2em; color: #ccc; cursor: pointer; transition: color 0.3s ease, transform 0.3s ease; }
        .feature-modal-close:hover { color: #999; transform: rotate(90deg); }
        .feature-modal-body .form-group { margin-bottom: 15px; }
        .feature-modal-body .form-group input, .feature-modal-body .form-group textarea { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-family: var(--font-ui); box-sizing: border-box; }
        .feature-modal-footer { text-align: right; margin-top: 20px; }
        .feature-modal-submit-btn { padding: 10px 20px; background: var(--accent-dark-color); color: white; border: none; border-radius: 8px; cursor: pointer; }
        
        #mind-voice-modal-content { background: rgba(0,0,0,0.7); color: white; padding: 25px; border-radius: 15px; max-width: 90%; max-height: 70vh; overflow-y: auto; font-family: var(--font-ui); font-size: 1.1em; line-height: 1.6; border: 1px solid rgba(255,255,255,0.2); }
        #mind-voice-modal-content p { margin: 0; }
        #mind-voice-close-btn { position: absolute; top: 15px; right: 15px; background: none; border: none; font-size: 2.5em; color: white; cursor: pointer; line-height: 1; text-shadow: 0 0 5px black; }

        #sticker-gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; max-height: 300px; overflow-y: auto; padding: 5px; border: 1px solid #eee; border-radius: 8px; }
        #sticker-gallery img { width: 100%; height: 80px; object-fit: cover; border-radius: 8px; cursor: pointer; transition: transform 0.2s; }
        #sticker-gallery img:hover { transform: scale(1.1); }

        /* --- Video Call Overlay --- */
        #video-call-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1001; display: none; flex-direction: column; justify-content: space-between; align-items: center; color: white; font-family: var(--font-ui); padding: 20px; box-sizing: border-box; }
        #video-call-overlay.show { display: flex; }
        .video-main-view { width: 100%; height: 100%; position: absolute; top: 0; left: 0; object-fit: cover; opacity: 0.3; z-index: -1; }
        .video-self-view { position: absolute; top: 20px; right: 20px; width: 100px; height: 150px; border: 2px solid white; border-radius: 12px; object-fit: cover; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .video-character-info { z-index: 2; text-align: center; margin-top: 6vh; flex-shrink: 0; }
        .video-character-info .avatar { width: 120px; height: 120px; border-radius: 50%; border: 4px solid white; }
        .video-character-info h2 { margin: 10px 0 5px 0; font-size: 1.8em; }
        .video-character-info p { font-size: 1em; color: #eee; }
        #video-chat-log { z-index: 2; width: 100%; max-width: 500px; flex-grow: 1; margin-top: 15px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; }
        #video-chat-log::-webkit-scrollbar { display: none; }
        .video-chat-message { padding: 8px 12px; border-radius: 12px; max-width: 70%; word-wrap: break-word; font-family: var(--font-main); }
        .video-chat-message i { font-style: italic; opacity: 0.8; }
        .video-chat-message.user { background: rgba(255,255,255,0.2); align-self: flex-end; }
        .video-chat-message.ai { background: rgba(0,0,0,0.2); align-self: flex-start; }
        #video-input-area { z-index: 2; display: flex; width: 100%; max-width: 520px; margin: 15px 0; gap: 10px; flex-shrink: 0; }
        #video-message-input { flex-grow: 1; background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3); color: white; border-radius: 18px; padding: 8px 15px; font-family: var(--font-main); }
        #video-message-input::placeholder { color: rgba(255,255,255,0.6); }
        #video-send-btn { background: var(--accent-color); border: none; border-radius: 18px; color: white; padding: 8px 18px; cursor: pointer; font-family: var(--font-ui); }
        .video-controls { z-index: 2; margin-bottom: 2vh; display: flex; gap: 40px; flex-shrink: 0; }
        .video-btn { width: 70px; height: 70px; border-radius: 50%; border: none; cursor: pointer; display: flex; justify-content: center; align-items: center; }
        .video-btn svg { width: 35px; height: 35px; fill: white; }
        .video-btn.accept { background-color: var(--success-color); }
        .video-btn.decline { background-color: var(--delete-color); }
        
        /* --- MODALS (Settings, Delete, etc) --- */
        #delete-toolbar { position: absolute; bottom: 0; left: 0; width: 100%; box-sizing: border-box; background: var(--header-bg-color); padding: 15px 20px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; z-index: 5; }
        #delete-toolbar.show { opacity: 1; visibility: visible; }
        #delete-info { font-family: var(--font-ui); color: var(--text-color); }
        #delete-actions button { font-family: var(--font-ui); font-size: 0.9em; padding: 8px 16px; border: none; border-radius: 10px; cursor: pointer; transition: background-color 0.2s ease; }
        #confirm-delete-btn { background-color: var(--delete-color); color: white; margin-right: 10px; }
        #cancel-delete-btn { background-color: #eee; color: #555; }
        
        .settings-content { background: #fff; padding: 25px 35px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.1); width: 90%; max-width: 600px; max-height: 90vh; display: flex; flex-direction: column; font-family: var(--font-ui); }
        .settings-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; border-bottom: 1px solid #eee; padding-bottom: 15px; }
        .settings-header h2 { margin: 0; font-family: var(--font-logo); color: var(--accent-dark-color); font-size: 2em; }
        .close-btn { background: none; border: none; font-size: 2em; color: #ccc; cursor: pointer; transition: color 0.3s ease, transform 0.3s ease; }
        .close-btn:hover { color: #999; transform: rotate(90deg); }
        .settings-body { overflow-y: auto; padding-right: 15px; }
        .settings-body::-webkit-scrollbar { width: 5px; }
        .settings-body::-webkit-scrollbar-track { background: #f1f1f1; }
        .settings-body::-webkit-scrollbar-thumb { background: #ddd; border-radius: 10px; }
        .settings-section { margin-bottom: 25px; }
        .settings-section h3 { margin: 0 0 15px 0; font-weight: 500; color: var(--accent-color); border-left: 3px solid var(--accent-color); padding-left: 10px; }
        .form-group { margin-bottom: 15px; display: flex; flex-direction: column; }
        .form-group label { margin-bottom: 5px; font-size: 0.9em; color: #666; }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; font-family: var(--font-ui); box-sizing: border-box; transition: border-color 0.3s, box-shadow 0.3s; }
        .form-group input:focus, .form-group select:focus, .form-group textarea:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 5px var(--accent-color); }
        .form-group textarea { min-height: 120px; resize: vertical; }
        .model-group { display: flex; align-items: center; gap: 10px; }
        .model-group button { padding: 10px 15px; background: var(--accent-color); color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.3s ease; white-space: nowrap; }
        .avatar-upload-group { display: flex; align-items: center; gap: 15px; }
        .avatar-preview { width: 60px; height: 60px; border-radius: 8px; object-fit: cover; border: 2px dashed var(--border-color); }
        .file-input-label { background: #f7f7f7; border: 1px solid #ddd; border-radius: 8px; padding: 8px 12px; cursor: pointer; font-size: 0.9em; transition: background-color 0.3s ease; display: inline-block; text-align: center; }
        .theme-selector { display: flex; gap: 10px; flex-wrap: wrap; }
        .theme-option { flex-grow: 1; padding: 10px; border-radius: 8px; cursor: pointer; border: 2px solid transparent; text-align: center; transition: all 0.3s ease; }
        .theme-option.active { border-color: var(--accent-dark-color); font-weight: 500; }
        .theme-option span { display: block; width: 20px; height: 20px; border-radius: 5px; margin: 5px auto 0 auto; background: var(--user-bubble-bg); }
        #theme1 { background: #f9f9f9; } #theme1 span { background: var(--theme1-user-bg); }
        #theme2 { background: #f9f9f9; } #theme2 span { background: var(--theme2-user-bg); }
        #theme3 { background: #f9f9f9; } #theme3 span { background: var(--theme3-user-bg); }
        #theme4 { background: #f9f9f9; } #theme4 span { background: var(--theme4-user-bg); }
        #theme5 { background: #f9f9f9; } #theme5 span { background: var(--theme5-user-bg); }
        .data-zone button, .sticker-zone button { width: 100%; padding: 10px; background-color: #fff; color: var(--accent-color); border: 1px solid var(--accent-color); border-radius: 8px; cursor: pointer; transition: background-color 0.2s, color 0.2s; }
        .data-zone button:hover, .sticker-zone button:hover { background-color: var(--accent-color); color: white; border-color: var(--accent-color); }
        .danger-zone button { color: var(--delete-color); border-color: var(--delete-color); }
        .danger-zone button:hover { background-color: var(--delete-color); color: white; border-color: var(--delete-color); }
        #delete-character-btn { margin-top: 10px; }
        .settings-footer { margin-top: 20px; text-align: right; border-top: 1px solid #eee; padding-top: 20px; }
        #save-settings-btn { padding: 12px 25px; font-size: 1em; font-weight: 500; background: var(--accent-dark-color); color: white; border: none; border-radius: 10px; cursor: pointer; transition: background-color 0.3s ease, transform 0.2s ease; }
        #save-settings-btn:hover { background-color: #e06387; transform: translateY(-2px); }

        /* --- Moments (朋友圈) Modal --- */
        #moments-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fdfdfd; z-index: 2000; display: none; flex-direction: column; }
        #moments-overlay.show { display: flex; animation: fadeIn 0.3s ease; }
        
        #moments-feed-container { flex-grow: 1; overflow-y: auto; background-color: #fff; }
        
        #moments-cover-area { position: relative; width: 100%; height: 35vh; background-color: #eee; background-size: cover; background-position: center; flex-shrink: 0; }
        #moments-user-info { position: absolute; bottom: -25px; right: 20px; display: flex; align-items: flex-end; gap: 15px; }
        #moments-user-name { color: white; font-size: 1.2em; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); margin-bottom: 5px; font-weight: bold; }
        #moments-user-avatar { width: 80px; height: 80px; border-radius: 12px; object-fit: cover; border: 3px solid white; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        
        #moments-header { position: absolute; top: 0; left: 0; width: 100%; display: flex; align-items: center; justify-content: space-between; padding: 15px; box-sizing: border-box; background: linear-gradient(to bottom, rgba(0,0,0,0.3), transparent); }
        #moments-close-btn { background: rgba(0,0,0,0.2); border: none; color: white; width: 30px; height: 30px; border-radius: 50%; font-size: 1.5em; line-height: 30px; text-align: center; cursor: pointer; transition: background-color 0.2s; }
        #moments-close-btn:hover { background: rgba(0,0,0,0.4); }
        #post-new-moment-btn { background: rgba(255,255,255,0.9); border: none; color: var(--accent-dark-color); padding: 8px; border-radius: 50%; cursor: pointer; box-shadow: 0 1px 5px rgba(0,0,0,0.1); }
        #post-new-moment-btn svg { width: 24px; height: 24px; display: block; }

        #moments-feed { padding-top: 45px; } /* Space for cover overlap */
        .moment-post { border-bottom: 1px solid #f0f0f0; padding: 15px 20px; display: flex; gap: 12px; }
        .moment-post:last-child { border-bottom: none; }
        .moment-avatar { width: 45px; height: 45px; border-radius: 8px; object-fit: cover; flex-shrink: 0; cursor: pointer; }
        .moment-body { flex-grow: 1; }
        .moment-username { font-weight: 500; color: var(--accent-dark-color); margin-bottom: 8px; }
        .moment-content { margin-bottom: 10px; font-size: 0.95em; line-height: 1.6; color: #444; white-space: pre-wrap; }
        .moment-image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 5px; margin-bottom: 10px; }
        .moment-image-grid img { width: 100%; height: 100px; object-fit: cover; border-radius: 8px; }
        .moment-image { width: 100%; max-width: 300px; border-radius: 12px; object-fit: cover; margin-bottom: 10px; }
        .moment-footer { display: flex; justify-content: space-between; align-items: center; font-size: 0.8em; color: var(--text-light-color); }
        .moment-actions button { background: none; border: none; cursor: pointer; color: var(--text-light-color); padding: 5px 8px; border-radius: 5px; transition: background-color 0.2s, color 0.2s; }
        .moment-actions button:hover { background-color: #fcefee; }
        .moment-actions button.liked { color: var(--accent-dark-color); font-weight: bold; }
        .moment-actions button svg { width: 16px; height: 16px; vertical-align: middle; margin-right: 4px; }
        .moment-comments { margin-top: 10px; background: #fafafa; border-radius: 8px; padding: 2px 10px; }
        .comment { padding: 6px 0; border-bottom: 1px solid #f0f0f0; font-size: 0.9em; }
        .comment:last-child { border-bottom: none; }
        .comment-user { color: var(--accent-color); font-weight: 500; }
        .comment-input-form { display: flex; margin-top: 8px; gap: 5px; }
        .comment-input-form input { flex-grow: 1; border: 1px solid #eee; border-radius: 15px; padding: 5px 10px; font-size: 0.9em; font-family: var(--font-ui); }
        .comment-input-form input:focus { border-color: var(--accent-color); outline: none; }
        .comment-input-form button { background: var(--accent-color); color: white; border: none; border-radius: 15px; padding: 5px 12px; font-size: 0.85em; cursor: pointer; }

        /* --- Chat Management (Character & Group) Modal --- */
        .chat-manager-tabs { display: flex; border-bottom: 1px solid var(--border-color); margin-bottom: 15px; }
        .chat-manager-tab { padding: 10px 20px; cursor: pointer; font-size: 1.1em; color: var(--text-light-color); position: relative; }
        .chat-manager-tab.active { color: var(--accent-dark-color); font-weight: 500; }
        .chat-manager-tab.active::after { content: ''; position: absolute; bottom: -1px; left: 0; right: 0; height: 2px; background-color: var(--accent-dark-color); }
        .chat-manager-content { display: none; }
        .chat-manager-content.active { display: block; }
        .chat-list { max-height: 50vh; overflow-y: auto; padding-right: 10px; }
        .chat-item { display: flex; align-items: center; padding: 12px; border-radius: 10px; margin-bottom: 10px; cursor: pointer; transition: background-color 0.2s; border: 1px solid #eee; }
        .chat-item:hover { background-color: #fcf6f8; }
        .chat-item.active { background-color: var(--bg-color); border-color: var(--accent-color); }
        .chat-item img { width: 50px; height: 50px; border-radius: 8px; object-fit: cover; margin-right: 15px; }
        .chat-item .name { font-weight: 500; font-size: 1.1em; flex-grow: 1; }
        .chat-item .delete-btn { background: none; border: none; cursor: pointer; color: #ccc; font-size: 1.5em; padding: 0 5px; transition: color 0.2s; }
        .chat-item .delete-btn:hover { color: var(--delete-color); }
        .add-new-btn { width: 100%; padding: 12px; background-color: var(--accent-color); color: white; border: none; border-radius: 10px; cursor: pointer; font-size: 1em; font-family: var(--font-ui); margin-top: 15px; }
        #create-group-members { max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 10px; }
        .member-select-item { display: flex; align-items: center; gap: 10px; padding: 8px; border-radius: 8px; }
        .member-select-item:hover { background: #f7f7f7; }
        .member-select-item input[type=checkbox] { width: 20px; height: 20px; cursor: pointer; }
    </style>
</head>
<body>
    <div id="chat-container">
        <div id="chat-header">
            <button id="chat-manager-btn" title="チャット切り替え">
                <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M16.5 12c1.38 0 2.5-1.12 2.5-2.5S17.88 7 16.5 7C15.12 7 14 8.12 14 9.5s1.12 2.5 2.5 2.5zM9 11c1.66 0 3-1.34 3-3S10.66 5 9 5C7.34 5 6 6.34 6 8s1.34 3 3 3zm7.5 3c-1.83 0-5.5.92-5.5 2.75V19h11v-2.25c0-1.83-3.67-2.75-5.5-2.75zM9 13c-2.33 0-7 1.17-7 3.5V19h7v-2.25c0-.85.33-2.34 2.37-3.47C10.5 13.1 9.66 13 9 13z"/></svg>
            </button>
            <img id="header-avatar" src="" title="彼の心を読む / グループ情報">
            <h1 id="chat-name-header" contenteditable="true"></h1>
            <button id="settings-btn" title="設定">
                <svg viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17-.59-1.69-.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
            </button>
        </div>

        <div id="messages"></div>

        <div id="bottom-panel">
            <div id="action-panel">
                <div class="action-item" id="action-show-moments">
                    <div class="action-item-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 20H4v-4h4v4zm0-6H4v-4h4v4zm0-6H4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4zm6 12h-4v-4h4v4zm0-6h-4v-4h4v4zm0-6h-4V4h4v4z"/></svg></div>
                    <span>モーメンツ</span>
                </div>
                <div class="action-item" id="action-send-text-image">
                    <div class="action-item-icon"><svg viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg></div>
                    <span>画像説明</span>
                </div>
                <div class="action-item" id="action-send-voice">
                    <div class="action-item-icon"><svg viewBox="0 0 24 24"><path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 14 6.7 11H5c0 3.41 2.72 6.23 6 6.72V21h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z"/></svg></div>
                    <span>ボイス</span>
                </div>
                <div class="action-item" id="action-send-transfer">
                     <div class="action-item-icon"><svg viewBox="0 0 24 24"><path d="M20 4H4c-1.11 0-2 .89-2 2v12c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm-1 14H5c-.55 0-1-.45-1-1V7c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v10c0 .55-.45 1-1 1zM9 14h6c.55 0 1-.45 1-1s-.45-1-1-1H9c-.55 0-1 .45-1 1s.45 1 1 1zm-2.5-4c.83 0 1.5-.67 1.5-1.5S7.33 7 6.5 7 5 7.67 5 8.5 5.67 10 6.5 10z"/></svg></div>
                    <span>送金</span>
                </div>
                 <div class="action-item" id="action-send-sticker">
                    <div class="action-item-icon"><svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1.5-6.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5.67-1.5 1.5-1.5zm3-2c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5-1.5-.67-1.5-1.5.67-1.5 1.5-1.5zM8 12.5c0 .83-.67 1.5-1.5 1.5S5 13.33 5 12.5 5.67 11 6.5 11s1.5.67 1.5 1.5z"/></svg></div>
                    <span>スタンプ</span>
                </div>
                 <div class="action-item" id="action-video-call">
                    <div class="action-item-icon"><svg viewBox="0 0 24 24"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z"/></svg></div>
                    <span>ビデオ</span>
                </div>
                 <div class="action-item" id="action-send-real-image">
                    <div class="action-item-icon"><svg viewBox="0 0 24 24" style="fill: #8BC34A"><path d="M4 4h7V2H4c-1.1 0-2 .9-2 2v7h2V4zm6 9-3 3.99h12l-4-5.01-3.01 4.02L9 15l-2-2.01zM20 2h-7v2h7v7h2V4c0-1.1-.9-2-2-2zM4 13H2v7c0 1.1.9 2 2 2h7v-2H4v-7z"/></svg></div>
                    <span>アルバム</span>
                </div>
                <div class="action-item" id="action-create-poll">
                    <div class="action-item-icon"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"><path d="M0 0h24v24H0z" fill="none"/><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-4h2v4zm4 0h-2v-2h2v2zm0-4h-2V7h2v6zm4 4h-2v-6h2v6z"/></svg></div>
                    <span>投票</span>
                </div>
            </div>
            <div id="input-area">
                 <button id="action-btn" title="他の機能">
                     <svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>
                </button>
                <textarea id="message-input" placeholder="メッセージを入力..." rows="1"></textarea>
                <button id="send-btn" title="送信">
                    <svg viewBox="0 0 24 24"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
                </button>
            </div>
            <div id="delete-toolbar">
                <span id="delete-info"></span>
                <div id="delete-actions">
                    <button id="confirm-delete-btn">削除</button>
                    <button id="cancel-delete-btn">キャンセル</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals below -->
    <div id="settings-modal" class="modal-overlay">
        <div class="settings-content">
            <div class="settings-header">
                <h2>設定</h2>
                <button class="close-btn">&times;</button>
            </div>
            <div class="settings-body">
                <div class="settings-section">
                    <h3>API & モデル設定</h3>
                    <div class="form-group"><label for="api-base-url">APIエンドポイント (Base URL)</label><input type="text" id="api-base-url" placeholder="例: https://api.openai.com"></div>
                    <div class="form-group"><label for="api-key">APIキー (API Key)</label><input type="password" id="api-key" placeholder="APIキーをここに入力してください"></div>
                    <div class="form-group"><label for="model-select">モデル選択</label><div class="model-group"><select id="model-select"></select><button id="fetch-models-btn">モデルリスト取得</button></div></div>
                </div>

                <div class="settings-section">
                    <h3>グローバル設定</h3>
                    <div class="form-group"><label for="custom-system-prompt">カスタムシステムプロンプト</label><textarea id="custom-system-prompt" placeholder="AIの応答形式を定義するグローバルな指示。空欄の場合はデフォルト設定が使用されます。"></textarea></div>
                </div>

                <div class="settings-section">
                    <h3>デザイン設定</h3>
                    <div class="form-group"><label>チャットバブルのテーマ</label><div class="theme-selector"><div class="theme-option active" data-theme="1">白/黒<span></span></div><div class="theme-option" data-theme="2">黒/白<span></span></div><div class="theme-option" data-theme="3">空色<span></span></div><div class="theme-option" data-theme="4">若草色<span></span></div><div class="theme-option" data-theme="5">桜色<span></span></div></div></div>
                    <div class="form-group"><label for="background-upload-input">チャット背景</label><label class="file-input-label" for="background-upload-input">背景画像を選択</label></div>
                </div>

                 <div class="settings-section sticker-zone">
                    <h3>スタンプ管理</h3>
                    <div class="form-group" style="gap: 10px; flex-direction: row;"><button id="manage-stickers-btn">自分のスタンプ管理</button><button id="manage-ai-stickers-btn">彼のスタンプ管理</button></div>
                </div>

                <div class="settings-section" id="character-settings-section">
                    <h3>彼のプロフィール設定</h3>
                    <div class="form-group"><label for="character-name-input">彼の名前</label><input type="text" id="character-name-input" placeholder="ヘッダーに表示される名前"></div>
                    <div class="form-group"><label for="ai-avatar-upload-input">彼のアイコン</label><div class="avatar-upload-group"><img id="ai-avatar-preview" src="" class="avatar-preview"><label class="file-input-label" for="ai-avatar-upload-input">画像を選択</label></div></div>
                    <div class="form-group"><label for="memory-size-input">彼の記憶容量 (メッセージ数)</label><input type="number" id="memory-size-input" placeholder="デフォルト: 50"></div>
                    <div class="form-group"><label for="character-prompt">彼の人格設定 (System Prompt)</label><textarea id="character-prompt" placeholder="彼の人格、話し方、背景などをここに設定します。(空欄の場合はデフォルト設定を使用)"></textarea></div>
                </div>

                <div class="settings-section">
                    <h3>自分のプロフィール設定</h3>
                     <div class="form-group"><label for="user-avatar-upload-input">自分のアイコン</label><div class="avatar-upload-group"><img id="user-avatar-preview" src="" class="avatar-preview"><label class="file-input-label" for="user-avatar-upload-input">画像を選択</label></div></div>
                    <div class="form-group"><label for="user-moments-avatar-upload-input">モーメンツ用アイコン</label><div class="avatar-upload-group"><img id="user-moments-avatar-preview" src="" class="avatar-preview"><label class="file-input-label" for="user-moments-avatar-upload-input">画像を選択</label></div></div>
                    <div class="form-group"><label for="user-moments-cover-upload-input">モーメンツ用カバー画像</label><div class="avatar-upload-group"><img id="user-moments-cover-preview" src="" class="avatar-preview"><label class="file-input-label" for="user-moments-cover-upload-input">画像を選択</label></div></div>
                    <div class="form-group"><label for="user-prompt">自分について</label><textarea id="user-prompt" placeholder="あなたの名前や好きなことなどを教え、会話をよりパーソナルにしましょう。"></textarea></div>
                </div>
                
                <div class="settings-section data-zone">
                    <h3>データ管理</h3>
                     <div class="form-group" style="gap: 10px; flex-direction: row;">
                        <button id="export-data-btn">全データのエクスポート</button>
                        <button id="import-data-btn">データのインポート</button>
                     </div>
                </div>

                <div class="settings-section danger-zone" id="danger-zone-section">
                    <h3>チャット履歴の管理</h3>
                    <div class="form-group"><button id="clear-history-btn">全会話履歴を消去</button></div>
                    <div class="form-group" id="delete-character-btn-container"><button id="delete-character-btn">このキャラクターを削除</button></div>
                </div>

            </div>
            <div class="settings-footer"><button id="save-settings-btn">設定を保存</button></div>
        </div>
    </div>
    
    <div id="feature-modal" class="modal-overlay">
        <div class="feature-modal-content">
            <div class="feature-modal-header">
                <h3 id="feature-modal-title"></h3>
                <button class="feature-modal-close">&times;</button>
            </div>
            <div id="feature-modal-body" class="feature-modal-body"></div>
            <div class="feature-modal-footer">
                <button id="feature-modal-submit-btn" class="feature-modal-submit-btn"></button>
            </div>
        </div>
    </div>
    
    <div id="mind-voice-modal" class="modal-overlay">
        <div id="mind-voice-modal-content">
            <p id="mind-voice-content"></p>
        </div>
        <button id="mind-voice-close-btn">&times;</button>
    </div>

    <div id="video-call-overlay">
        <img id="video-main-view" src="" class="video-main-view">
        <img id="video-self-view" src="" class="video-self-view">
        <div class="video-character-info">
            <img id="video-character-avatar" src="" class="avatar">
            <h2 id="video-character-name"></h2>
            <p id="video-status-text"></p>
        </div>
        <div id="video-chat-log"></div>
        <div id="video-input-area">
            <input type="text" id="video-message-input" placeholder="何か話す...">
            <button id="video-send-btn">送信</button>
        </div>
        <div id="video-controls" class="video-controls"></div>
    </div>

    <div id="moments-overlay">
        <div id="moments-feed-container">
            <div id="moments-cover-area">
                <div id="moments-header">
                    <button id="moments-close-btn">&times;</button>
                    <button id="post-new-moment-btn" title="新規投稿">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="currentColor"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>
                    </button>
                </div>
                <div id="moments-user-info">
                    <span id="moments-user-name"></span>
                    <img id="moments-user-avatar" src="">
                </div>
            </div>
            <div id="moments-feed">
                <!-- Moment posts will be dynamically inserted here -->
            </div>
        </div>
    </div>
    
    <!-- Hidden file inputs -->
    <input type="file" id="real-image-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="transfer-cover-input" accept="image/*" style="display:none;">
    <input type="file" id="sticker-upload-input" accept="image/*" multiple style="display:none;">
    <input type="file" id="background-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="ai-avatar-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="group-avatar-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="user-avatar-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="user-moments-avatar-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="user-moments-cover-upload-input" accept="image/*" style="display:none;">
    <input type="file" id="import-data-input" accept=".json" style="display:none;">
    <input type="file" id="moment-post-image-input" accept="image/*" style="display:none;">


    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const getEl = (id) => document.getElementById(id);
        const queryEl = (sel) => document.querySelector(sel);
        
        const elements = {
            chatContainer: getEl('chat-container'),
            chatHeader: getEl('chat-header'),
            chatManagerBtn: getEl('chat-manager-btn'),
            headerAvatar: getEl('header-avatar'),
            chatNameHeader: getEl('chat-name-header'),
            settingsBtn: getEl('settings-btn'),
            messagesContainer: getEl('messages'),
            
            bottomPanel: getEl('bottom-panel'),
            actionPanel: getEl('action-panel'),
            inputArea: getEl('input-area'),
            actionBtn: getEl('action-btn'),
            messageInput: getEl('message-input'),
            sendBtn: getEl('send-btn'),
            
            deleteToolbar: getEl('delete-toolbar'),
            deleteInfo: getEl('delete-info'),
            confirmDeleteBtn: getEl('confirm-delete-btn'),
            cancelDeleteBtn: getEl('cancel-delete-btn'),
            
            actionShowMoments: getEl('action-show-moments'),
            actionSendTextImage: getEl('action-send-text-image'), 
            actionSendVoice: getEl('action-send-voice'),
            actionSendTransfer: getEl('action-send-transfer'), 
            actionSendSticker: getEl('action-send-sticker'),
            actionVideoCall: getEl('action-video-call'), 
            actionSendRealImage: getEl('action-send-real-image'),
            actionCreatePoll: getEl('action-create-poll'),

            realImageUploadInput: getEl('real-image-upload-input'),
            transferCoverInput: getEl('transfer-cover-input'),
            stickerUploadInput: getEl('sticker-upload-input'),
            backgroundUploadInput: getEl('background-upload-input'),
            aiAvatarUploadInput: getEl('ai-avatar-upload-input'),
            groupAvatarUploadInput: getEl('group-avatar-upload-input'),
            userAvatarUploadInput: getEl('user-avatar-upload-input'),
            userMomentsAvatarInput: getEl('user-moments-avatar-upload-input'),
            userMomentsCoverInput: getEl('user-moments-cover-upload-input'),
            importDataInput: getEl('import-data-input'),
            momentPostImageInput: getEl('moment-post-image-input'),

            featureModal: getEl('feature-modal'),
            featureModalTitle: getEl('feature-modal-title'),
            featureModalBody: getEl('feature-modal-body'),
            featureModalSubmitBtn: getEl('feature-modal-submit-btn'),
            featureModalCloseBtn: getEl('feature-modal').querySelector('.feature-modal-close'),

            mindVoiceModal: getEl('mind-voice-modal'),
            mindVoiceContent: getEl('mind-voice-content'),
            mindVoiceCloseBtn: getEl('mind-voice-close-btn'),

            videoCallOverlay: getEl('video-call-overlay'),
            videoMainView: getEl('video-main-view'),
            videoSelfView: getEl('video-self-view'),
            videoCharacterAvatar: getEl('video-character-avatar'),
            videoCharacterName: getEl('video-character-name'),
            videoStatusText: getEl('video-status-text'),
            videoControls: getEl('video-controls'),
            videoChatLog: getEl('video-chat-log'),
            videoMessageInput: getEl('video-message-input'),
            videoSendBtn: getEl('video-send-btn'),
            
            momentsOverlay: getEl('moments-overlay'),
            momentsCoverArea: getEl('moments-cover-area'),
            momentsUserAvatar: getEl('moments-user-avatar'),
            momentsUserName: getEl('moments-user-name'),
            momentsCloseBtn: getEl('moments-close-btn'),
            postNewMomentBtn: getEl('post-new-moment-btn'),
            momentsFeed: getEl('moments-feed'),

            settingsModal: getEl('settings-modal'),
            closeSettingsBtn: getEl('settings-modal').querySelector('.close-btn'),
            saveSettingsBtn: getEl('save-settings-btn'),
            apiBaseUrlInput: getEl('api-base-url'),
            apiKeyInput: getEl('api-key'),
            modelSelect: getEl('model-select'),
            fetchModelsBtn: getEl('fetch-models-btn'),
            customSystemPromptInput: getEl('custom-system-prompt'),
            themeSelector: queryEl('.theme-selector'),
            manageStickersBtn: getEl('manage-stickers-btn'),
            manageAiStickersBtn: getEl('manage-ai-stickers-btn'),
            characterSettingsSection: getEl('character-settings-section'),
            characterNameInput: getEl('character-name-input'),
            aiAvatarPreview: getEl('ai-avatar-preview'),
            memorySizeInput: getEl('memory-size-input'),
            characterPromptInput: getEl('character-prompt'),
            userAvatarPreview: getEl('user-avatar-preview'),
            userMomentsAvatarPreview: getEl('user-moments-avatar-preview'),
            userMomentsCoverPreview: getEl('user-moments-cover-preview'),
            userPromptInput: getEl('user-prompt'),
            exportDataBtn: getEl('export-data-btn'),
            importDataBtn: getEl('import-data-btn'),
            dangerZoneSection: getEl('danger-zone-section'),
            clearHistoryBtn: getEl('clear-history-btn'),
            deleteCharacterBtnContainer: getEl('delete-character-btn-container'),
            deleteCharacterBtn: getEl('delete-character-btn'),
        };

        // --- State Management ---
        let characterSets = [];
        let groupChats = [];
        let userMomentsProfile = {};
        let currentChat = { type: 'direct', id: null }; // { type: 'direct' | 'group', id: '...' }
        let isMultiSelectMode = false, selectedMessageIds = [];
        let responseTriggerTimer = null, isActionPanelOpen = false, isVideoCallActive = false;
        
        const DEFAULT_SYSTEM_PROMPT = `[役割定義]
あなたはチャットアプリケーションのAIキャラクターです。あなたの目標は、魅力的でリアル、そして一貫した会話パートナーであることです。

[出力形式の指示]
- あなたの応答全体は、必ずJSON配列でなければなりません。配列の各要素は、一つのアクションやメッセージを表すオブジェクトです。
- このJSON配列の外には、何も出力してはいけません。余分なテキスト、マークダウン、説明は不要です。
- 複数のメッセージオブジェクトを一つの配列に組み合わせることで、連続してメッセージを送信できます。

[利用可能なアクションタイプ]
1.  {"type": "text", "content": "ここにテキストメッセージを入力"}
2.  {"type": "voice", "content": "音声メッセージのテキスト版"}
3.  {"type": "sticker", "sticker_id": "optional_id"}
4.  {"type": "text-image", "content": "「見せている」画像の詳述"}
5.  {"type": "transfer", "amount": 12.34, "memo": "任意のメモ"}
6.  {"type": "video-call-request", "content": "「少しビデオチャットしない？」のような招待メッセージ"}
7.  {"type": "post_moment", "content": "SNS投稿用のテキスト", "image_query": "「雨の日のコーヒーカップ」のような画像用のキーワード"}
8.  {"type": "vote", "pollId": "poll_id_string", "option": "voted_option_string"}
9.  (群聊専用) 上記のアクションに "senderId": "キャラクターID" を追加してください。例: {"senderId": "char_abc", "type": "text", "content": "..."}

[人格の核]
- ユーザーによって提供された「彼の人格設定（System Prompt）」セクションで定義されたペルソナに厳密に従わなければなりません。
- 文脈を把握するために、最近のチャット履歴を参照してください。`;

        // --- Utility Functions ---
        const getTimestamp = () => new Date().toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
        const getFullTimestamp = () => new Date().toLocaleString('ja-JP');
        const scrollToBottom = (container) => { container.scrollTop = container.scrollHeight; };
        const autoResizeTextarea = () => { elements.messageInput.style.height = 'auto'; elements.messageInput.style.height = (elements.messageInput.scrollHeight) + 'px'; };
        const generateId = (prefix) => `${prefix}_${Date.now()}${Math.random().toString(36).substring(2, 9)}`;
        
        const closeModal = (modal) => {
            if (!modal) return;
            modal.classList.add('hiding');
            const content = modal.querySelector('.feature-modal-content, .settings-content');
            if(content) content.classList.add('hiding');
            setTimeout(() => {
                modal.classList.remove('show', 'hiding');
                if(content) content.classList.remove('hiding');
            }, 300);
        };

        // --- Data & State Management ---
        const getCurrentCharacter = () => characterSets.find(c => c.id === currentChat.id);
        const getCurrentGroup = () => groupChats.find(g => g.id === currentChat.id);
        const getCurrentChatData = () => {
            if (currentChat.type === 'direct') return getCurrentCharacter();
            if (currentChat.type === 'group') return getCurrentGroup();
            return null;
        }

        const saveAllData = () => {
            const backupData = {
                characterSets,
                groupChats,
                currentChat,
                userMomentsProfile,
                customSystemPrompt: elements.customSystemPromptInput.value,
            };
            localStorage.setItem('aiBoyfriendBackup_v2', JSON.stringify(backupData));
        };

        const loadAllData = () => {
            const savedData = JSON.parse(localStorage.getItem('aiBoyfriendBackup_v2') || '{}');
            
            characterSets = savedData.characterSets || [];
            groupChats = savedData.groupChats || [];
            userMomentsProfile = savedData.userMomentsProfile || {
                name: '自分',
                avatar: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI2EwYTBiMyI+PHBhdGggZD0iTTEyIDEyYzIuMjEgMCA0LTEuNzkgNC00cy0xLjc5LTQtNC00LTQgMS43OS00IDQgMS43OSA0IDQgNHptMCAyYy0yLjY3IDAtOCAyLjI0LTggNC41VDIwYzAgLjU1IDMuNTggMS41IDggMS41czgtLjk1IDgtMS41di0xLjVjMC0yLjI2LTUuMzMtNC41LTgtNC41eiIvPjwvc3ZnPg==',
                cover: 'https://images.unsplash.com/photo-1507525428034-b723a996f3d5?q=80&w=1000',
                posts: []
            };
            elements.customSystemPromptInput.value = savedData.customSystemPrompt || '';

            if (characterSets.length === 0) {
                const newChar = createNewCharacterObject();
                characterSets.push(newChar);
                currentChat = { type: 'direct', id: newChar.id };
            } else {
                 currentChat = savedData.currentChat && ( (savedData.currentChat.type === 'direct' && characterSets.some(c => c.id === savedData.currentChat.id)) || (savedData.currentChat.type === 'group' && groupChats.some(g => g.id === savedData.currentChat.id)) ) ? savedData.currentChat : { type: 'direct', id: characterSets[0].id };
            }
            
            loadChat(currentChat.type, currentChat.id);
        };
        
        const createNewCharacterObject = () => {
            const id = generateId('char');
            return {
                id: id,
                config: {
                    characterName: '彼', 
                    theme: '1', 
                    aiAvatar: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBkPSJNNTAsMi41QzI0LjgsMi41LDIuNSwyNC44LDIuNSw1MHMxOS4zLDQ3LjUsNDcuNSw0Ny41czQ3LjUtMjIuMyw0Ny41LTQ3LjVMNTAsMi41eiBNMzgsNDQuOGMtMi4xLDAtMy44LTEuNy0zLjgtMy44czEuNy0zLjgsMy44LTMuOHMzLjgsMS43LDMuOCwzLjhTNDAuMSw0NC44LDM4LDQ0Ljh6IE02Miw0NC44Yy0yLjEsMC0zLjgtMS43LTMuOC0zLjghYzAtMi4xLDEuNy0zLjgsMy44LTMuOHMzLjgsMS43LDMuOCwzLjhDNTguMiw0My4xLDY0LjEsNDQuOCw2Miw0NC44eiBNNzcuNSw2Ny41YzAsMC0xMC03LjUtMjcuNS03LjVzLTI3LjUsNy41LTI3LjUsNy41cy0yLjUtMTAgMC0yMHMxMi41LTEyLjUsMjcuNS0xMi41czI3LjUsMi41LDI3LjUsMTIuNVM3Ny41LDY3LjUsNzcuNSw2Ny41eiIgZmlsbD0iI2ZlY2VkNiIvPjwvc3ZnPg==', 
                    userAvatar: userMomentsProfile.avatar, 
                    characterPrompt: '', 
                    userPrompt: '', 
                    apiBaseUrl: '', 
                    apiKey: '', 
                    model: '', 
                    memorySize: 50,
                    chatBackground: '',
                },
                chatHistory: [],
                userStickers: [],
                aiStickers: [],
                moments: []
            };
        };
        
        const createNewGroupObject = (name, avatar, memberIds) => {
            const id = generateId('group');
            return {
                id, name, avatar, memberIds,
                chatHistory: [],
                polls: [],
            };
        };

        const loadChat = (type, id) => {
            currentChat = { type, id };
            const chatData = getCurrentChatData();
            if (!chatData) return;

            // Configure UI based on chat type
            if (type === 'direct') {
                const { config } = chatData;
                elements.chatNameHeader.textContent = config.characterName;
                elements.headerAvatar.src = config.aiAvatar;
                elements.headerAvatar.onclick = showMindVoice;
                elements.settingsBtn.style.display = 'block';
                elements.actionShowMoments.style.display = 'flex';
                elements.actionVideoCall.style.display = 'flex';
                elements.actionCreatePoll.style.display = 'none';
                applySettings(config);
            } else if (type === 'group') {
                elements.chatNameHeader.textContent = chatData.name;
                elements.headerAvatar.src = chatData.avatar;
                elements.headerAvatar.onclick = null; // Or show group info modal
                elements.settingsBtn.style.display = 'none';
                elements.actionShowMoments.style.display = 'none';
                elements.actionVideoCall.style.display = 'none';
                elements.actionCreatePoll.style.display = 'flex';
            }
            
            renderAllMessages();
            saveAllData(); 
        };
        
        const saveCurrentCharacterSettings = () => {
            if (currentChat.type !== 'direct') return;
            const character = getCurrentCharacter();
            if (!character) return;
            
            character.config = {
                apiBaseUrl: elements.apiBaseUrlInput.value.trim(), 
                apiKey: elements.apiKeyInput.value.trim(), 
                model: elements.modelSelect.value,
                characterName: elements.characterNameInput.value.trim() || '彼', 
                characterPrompt: elements.characterPromptInput.value,
                userPrompt: elements.userPromptInput.value, 
                theme: elements.themeSelector.querySelector('.theme-option.active').dataset.theme,
                aiAvatar: elements.aiAvatarPreview.src, 
                userAvatar: elements.userAvatarPreview.src, 
                chatBackground: elements.chatContainer.style.backgroundImage,
                memorySize: parseInt(elements.memorySizeInput.value) || 50,
            };
            
            userMomentsProfile.avatar = elements.userAvatarPreview.src;
            userMomentsProfile.cover = elements.userMomentsCoverPreview.src;

            saveAllData();
            applySettings(character.config);
            loadChat('direct', character.id); // Reload chat to apply changes visually
        };
        
        const applyTheme = (theme) => {
            const root = document.documentElement;
            const themes = { '1': ['--theme1-ai-bg', '--theme1-ai-text', '--theme1-user-bg', '--theme1-user-text'], '2': ['--theme2-ai-bg', '--theme2-ai-text', '--theme2-user-bg', '--theme2-user-text'], '3': ['--theme3-ai-bg', '--theme3-ai-text', '--theme3-user-bg', '--theme3-user-text'], '4': ['--theme4-ai-bg', '--theme4-ai-text', '--theme4-user-bg', '--theme4-user-text'], '5': ['--theme5-ai-bg', '--theme5-ai-text', '--theme5-user-bg', '--theme5-user-text'],};
            const [aiBg, aiText, userBg, userText] = themes[theme];
            root.style.setProperty('--ai-bubble-bg', `var(${aiBg})`); root.style.setProperty('--ai-bubble-text', `var(${aiText})`);
            root.style.setProperty('--user-bubble-bg', `var(${userBg})`); root.style.setProperty('--user-bubble-text', `var(${userText})`);
            elements.themeSelector.querySelectorAll('.theme-option').forEach(opt => opt.classList.remove('active'));
            elements.themeSelector.querySelector(`.theme-option[data-theme="${theme}"]`).classList.add('active');
        };

        const applySettings = (settings) => {
            if (!settings) return;
            elements.characterNameInput.value = settings.characterName;
            elements.aiAvatarPreview.src = settings.aiAvatar;
            elements.userAvatarPreview.src = settings.userAvatar;
            elements.characterPromptInput.value = settings.characterPrompt;
            elements.userPromptInput.value = settings.userPrompt;
            elements.memorySizeInput.value = settings.memorySize;
            elements.apiBaseUrlInput.value = settings.apiBaseUrl;
            elements.apiKeyInput.value = settings.apiKey;
            if(settings.model && ![...elements.modelSelect.options].some(o => o.value === settings.model)) {
                elements.modelSelect.add(new Option(settings.model, settings.model, true, true));
            }
            if(settings.model) elements.modelSelect.value = settings.model;

            applyTheme(settings.theme || '1');
            if (settings.chatBackground) { elements.chatContainer.style.backgroundImage = settings.chatBackground; elements.chatContainer.style.backgroundSize = 'cover'; elements.chatContainer.style.backgroundPosition = 'center'; }
            else { elements.chatContainer.style.backgroundImage = ''; }
        };

        const handleFileUpload = (file, callback) => { if (file) { const reader = new FileReader(); reader.onload = (e) => callback(e.target.result); reader.readAsDataURL(file); } };
        
        const clearChatHistory = () => { 
            const chatData = getCurrentChatData();
            if(!chatData) return;
            const chatName = currentChat.type === 'direct' ? chatData.config.characterName : chatData.name;
            if (confirm(`「${chatName}」との会話履歴を全て消去しますか？この操作は元に戻せません。`)) { 
                chatData.chatHistory = []; 
                if (chatData.polls) chatData.polls = []; // Also clear polls in groups
                saveAllData(); 
                renderAllMessages(); 
                alert('会話履歴が消去されました。'); 
                closeModal(elements.settingsModal); 
            } 
        };

        // --- Chat & Message UI Logic ---
        const addMessage = (msgData, toHistory = true) => {
            const chatData = getCurrentChatData();
            if(!chatData) return;

            if (msgData.isLoading) {
                addMessageToUI({ ...msgData, id: 'typing-indicator' }, true);
                return;
            }
        
            const fullMessage = { id: generateId('msg'), timestamp: getTimestamp(), ...msgData };

            if (toHistory) {
                chatData.chatHistory.push(fullMessage);
                if (fullMessage.type === 'poll' && currentChat.type === 'group') {
                    chatData.polls.push({
                        pollId: fullMessage.pollId,
                        question: fullMessage.question,
                        options: fullMessage.options,
                        votes: {},
                        status: 'open'
                    });
                }
                saveAllData();
            }

            if (isVideoCallActive && fullMessage.isVideoCallMessage) {
                addVideoChatMessageToUI(fullMessage);
            } else if (!isVideoCallActive && !fullMessage.isVideoCallMessage) {
                addMessageToUI(fullMessage, true);
            }
            
            return fullMessage;
        };
        
        const addMessageToUI = (msg, isNew = false) => {
            const userAvatar = userMomentsProfile.avatar;
            const { sender, text, type = 'text', id, imageUrl, stickerUrl, transferAmount, transferMemo, transferCoverUrl, transferStatus, voiceDuration, isLoading } = msg;

            if (isLoading) {
                const typingIndicatorElement = document.createElement('div');
                typingIndicatorElement.className = `message ai typing-indicator`;
                typingIndicatorElement.id = 'typing-indicator';
                let typingAvatarSrc = '';
                if(currentChat.type === 'direct') {
                    typingAvatarSrc = getCurrentCharacter()?.config.aiAvatar || '';
                } else {
                    typingAvatarSrc = getCurrentGroup()?.avatar || '';
                }
                typingIndicatorElement.innerHTML = `<img class="avatar" src="${typingAvatarSrc}"><div class="message-content"><div class="bubble"><div class="typing-indicator"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div></div></div>`;
                elements.messagesContainer.appendChild(typingIndicatorElement);
                if (isNew) scrollToBottom(elements.messagesContainer);
                return;
            }
            
            const messageElement = document.createElement('div');
            messageElement.className = `message ${sender === 'user' ? 'user' : 'ai'}`;
             if (currentChat.type === 'group' && sender !== 'user') messageElement.classList.add('group-chat');

            if (type === 'system') {
                messageElement.classList.add('system');
                messageElement.innerHTML = `<span>${text}</span>`;
                elements.messagesContainer.appendChild(messageElement);
                if (isNew) scrollToBottom(elements.messagesContainer);
                return;
            }
            messageElement.dataset.id = id;

            // Determine Avatar & Name
            let senderData;
            if (sender === 'user') {
                 senderData = { avatar: userAvatar, name: userMomentsProfile.name };
            } else {
                const char = characterSets.find(c => c.id === sender);
                senderData = char ? { avatar: char.config.aiAvatar, name: char.config.characterName } : { avatar: '', name: 'Unknown' };
            }

            const avatar = document.createElement('img');
            avatar.className = 'avatar';
            avatar.src = senderData.avatar;
            avatar.title = senderData.name;

            const contentWrapper = document.createElement('div');
            contentWrapper.className = 'message-content';
            
            const senderNameDiv = document.createElement('div');
            senderNameDiv.className = 'sender-name';
            senderNameDiv.textContent = senderData.name;

            const bubble = document.createElement('div');
            bubble.className = `bubble message-${type}`;
            
            let bubbleContent = '';
            
            switch(type) {
                case 'text': bubbleContent = `<p>${text.replace(/\n/g, '<br>')}</p>`; break;
                case 'image': bubbleContent = `<img src="${imageUrl}" class="bubble-image-content" alt="送信された画像">`; break;
                case 'text-image': bubbleContent = `<div class="text-image-header"><svg viewBox="0 0 24 24"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg><span>写真を見せた</span></div><div class="text-image-description">${text}</div>`; break;
                case 'sticker': bubbleContent = `<img src="${stickerUrl}" class="bubble-image-content" alt="スタンプ" style="width:120px; height:120px; border: none;">`; break;
                case 'voice': bubble.style.width = `${Math.min(60 + (text?.length || 0) * 8, 250)}px`; bubbleContent = `<span class="voice-icon"><svg viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg></span><span class="voice-duration">${voiceDuration}</span>`; bubble.onclick = () => alert(`音声内容：\n\n${text}`); break;
                case 'transfer':
                    const recipientName = currentChat.type === 'direct' && sender === 'user' ? getCurrentCharacter()?.config.characterName || '相手' : 'あなた';
                    bubbleContent = `<img src="${transferCoverUrl}" class="transfer-cover" alt="Transfer"><div class="transfer-info"><div class="transfer-amount">¥ ${transferAmount}</div>${transferMemo ? `<div class="transfer-memo">${transferMemo}</div>` : ''}</div><div class="transfer-footer">${recipientName}への送金</div>`;
                    if (transferStatus === 'received') {
                        bubbleContent += `<div class="transfer-acknowledged">${sender === 'user' ? '相手が受領しました' : '受領しました'}</div>`;
                    } else if (sender !== 'user') { 
                        bubble.onclick = () => acknowledgeTransfer(id);
                    }
                    break;
                case 'poll':
                    if (currentChat.type === 'group') {
                       bubble.innerHTML = renderPoll(msg);
                    }
                    break;
            }
            if(type !== 'poll') bubble.innerHTML = bubbleContent;

            contentWrapper.append(senderNameDiv, bubble, Object.assign(document.createElement('div'), { className: 'timestamp', textContent: msg.timestamp }));
            messageElement.append(avatar, contentWrapper);
            
            let pressTimer = null, isLongPress = false;
            const startPress = (e) => { e.preventDefault(); isLongPress = false; pressTimer = setTimeout(() => { isLongPress = true; if (!isMultiSelectMode) toggleMultiSelectMode(true); toggleMessageSelection(messageElement); }, 750); };
            const cancelPress = () => clearTimeout(pressTimer);
            const clickHandler = () => { if (isMultiSelectMode && !isLongPress) toggleMessageSelection(messageElement); };
            
            messageElement.addEventListener('mousedown', startPress);
            messageElement.addEventListener('mouseup', cancelPress);
            messageElement.addEventListener('mouseleave', cancelPress);
            messageElement.addEventListener('touchstart', startPress, { passive: true });
            messageElement.addEventListener('touchend', cancelPress);
            messageElement.addEventListener('touchmove', cancelPress);
            messageElement.addEventListener('click', clickHandler);

            elements.messagesContainer.appendChild(messageElement);
            if (isNew) scrollToBottom(elements.messagesContainer);
        };
        
        const renderAllMessages = () => {
            const chatData = getCurrentChatData();
            if (!chatData) { elements.messagesContainer.innerHTML = ''; return; }
            elements.messagesContainer.innerHTML = ''; 
            chatData.chatHistory.forEach(msg => addMessageToUI(msg, false)); 
            scrollToBottom(elements.messagesContainer); 
        };

        // --- Core Logic ---
        const handleUserAction = (msgData) => {
            const content = msgData.text || msgData.imageUrl || msgData.stickerUrl || msgData.llmContent;
            if (!content && msgData.type !== 'poll') return;
            addMessage(msgData);
            if (responseTriggerTimer) clearTimeout(responseTriggerTimer);
            responseTriggerTimer = setTimeout(triggerAiResponse, 10000);
        };
        
        const triggerAiResponse = async () => {
            clearTimeout(responseTriggerTimer);
            const chatData = getCurrentChatData();
            if (!chatData || isVideoCallActive) return;

            // Use the first character's settings as a proxy for API credentials
            const apiCharacter = characterSets[0];
            if (!apiCharacter || !apiCharacter.config.apiBaseUrl || !apiCharacter.config.apiKey || !apiCharacter.config.model) {
                console.log("API settings are not configured. Cannot trigger AI response.");
                return;
            }
            
            addMessage({ sender: 'ai', type: 'text', isLoading: true }, false);

            const systemPrompt = elements.customSystemPromptInput.value.trim() || DEFAULT_SYSTEM_PROMPT;
            let fullPrompt;
            let messagesPayload;
            let memorySize = 50;

            if (currentChat.type === 'direct') {
                const character = chatData;
                memorySize = character.config.memorySize || 50;
                const characterPersonaPrompt = character.config.characterPrompt;
                fullPrompt = `${systemPrompt}\n\n[人格設定]:\n${characterPersonaPrompt}\n\n[ユーザー設定]: ${character.config.userPrompt || '未設定'}`;
                messagesPayload = [
                    { role: 'system', content: fullPrompt }, 
                    ...character.chatHistory.slice(-memorySize).map(m => ({ 
                        role: m.sender === 'user' ? 'user' : 'assistant', 
                        content: m.llmContent || m.text 
                    }))
                ];
            } else { // Group Chat
                const group = chatData;
                memorySize = 50; // Default memory for groups
                const memberProfiles = group.memberIds.map(id => {
                    const char = characterSets.find(c => c.id === id);
                    return char ? `\n### Character: ${char.config.characterName} (ID: ${id})\n${char.config.characterPrompt}` : '';
                }).join('\n');

                const openPollsInfo = group.polls.filter(p => p.status === 'open').map(p => {
                     const charVotes = Object.entries(p.votes).flatMap(([opt, voters]) => voters.filter(v => v !== 'user').map(v_id => ({id: v_id, option: opt})) );
                    return `\n[進行中の投票: "${p.question}" (ID: ${p.pollId})]
- 選択肢: ${p.options.join(', ')}
- 投票済みのメンバー: ${charVotes.length > 0 ? charVotes.map(v => `${characterSets.find(c=>c.id===v.id)?.config.characterName}が「${v.option}」に投票`).join('、') : 'まだ誰も投票していません'}`;
                }).join('');

                fullPrompt = `[役割定義]
あなたは高度なAI群聊协调员。あなたの仕事は、以下のキャラクターたちの役割を演じ、自然で活気のある群聊を作り出すことです。
${memberProfiles}

[タスク]
1. 最新のチャット履歴を読み、ユーザーのメッセージに誰がどのように反応すべきかを決定します。
2. キャラクター同士の自然な会話を促進します。
3. ${openPollsInfo ? `【重要】${openPollsInfo} まだ投票していないキャラクターは、自分の性格に基づいて投票することを検討してください。投票アクションは {"type": "vote", "senderId": "キャラクターID", "pollId": "投票ID", "option": "選択肢"} の形式で出力してください。` : ''}
4. あなたの応答は、発言するキャラクターのメッセージオブジェクトを含むJSON配列でなければなりません。各オブジェクトには、"senderId"（キャラクターID）を必ず含めてください。
[出力形式]
[
    {"senderId": "char_...", "type": "text", "content": "..."},
    {"senderId": "char_...", "type": "vote", "pollId": "...", "option": "..."}
]`;
                messagesPayload = [
                    { role: 'system', content: fullPrompt },
                    ...group.chatHistory.slice(-memorySize).map(m => ({
                        role: m.sender === 'user' ? 'user' : 'assistant',
                        content: `{"senderId": "${m.sender}", "content": ${JSON.stringify(m.llmContent || m.text)}}`
                    }))
                ];
            }
            
            try {
                const response = await fetch(`${apiCharacter.config.apiBaseUrl}/v1/chat/completions`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiCharacter.config.apiKey}` }, body: JSON.stringify({ model: apiCharacter.config.model, messages: messagesPayload, stream: false }) });
                getEl('typing-indicator')?.remove();
                if (!response.ok) { const errorData = await response.text(); throw new Error(`HTTP Error ${response.status}: ${errorData}`); }
                const responseData = await response.json();
                if (responseData?.choices?.[0]?.message?.content) {
                    processAiResponse(responseData.choices[0].message.content);
                } else if (responseData?.error) { throw new Error(`APIエラー: ${responseData.error.message}`);
                } else { throw new Error('APIレスポンスの形式が無効か、空です。'); }
            } catch (error) {
                getEl('typing-indicator')?.remove();
                addMessage({ sender: 'system', text: `エラー: ${error.message}`, type: 'system' });
            }
        };
        
        const processAiResponse = (rawText) => {
            let responseArray;
            try {
                const cleanedText = rawText.replace(/```json/g, '').replace(/```/g, '').trim();
                responseArray = JSON.parse(cleanedText);
                if (!Array.isArray(responseArray)) throw new Error("レスポンスが配列ではありません。");
            } catch (e) {
                console.error("AIレスポンスの解析エラー:", e, "\n生テキスト:", rawText);
                const senderId = currentChat.type === 'direct' ? currentChat.id : (getCurrentGroup()?.memberIds[0] || null);
                if (senderId) addMessage({ sender: senderId, text: rawText, type: 'text' });
                return;
            }

            // Acknowledge transfer and post moment
            const chatData = getCurrentChatData();
            if (chatData) {
                const lastUserMessage = [...chatData.chatHistory].reverse().find(m => m.sender === 'user');
                if(lastUserMessage && lastUserMessage.type === 'transfer' && lastUserMessage.transferStatus === 'pending') {
                    lastUserMessage.transferStatus = 'received';
                    saveAllData();
                    renderAllMessages();
                    
                    if (currentChat.type === 'direct') {
                        triggerAiMomentPostAfterTransfer(lastUserMessage.transferAmount);
                    }
                }
            }
            
            responseArray.forEach((msgObj, index) => {
                setTimeout(() => {
                    const senderId = msgObj.senderId || (currentChat.type === 'direct' ? currentChat.id : null);
                    if (!senderId) return;

                    const llmContent = JSON.stringify(msgObj);
                    const character = characterSets.find(c => c.id === senderId);

                    switch(msgObj.type) {
                        case 'text': addMessage({ sender: senderId, text: msgObj.content, type: 'text', llmContent }); break;
                        case 'voice': addMessage({ sender: senderId, text: msgObj.content, type: 'voice', voiceDuration: `0:${Math.max(1, Math.round((msgObj.content||'').length / 5)).toString().padStart(2, '0')}`, llmContent }); break;
                        case 'text-image': addMessage({ sender: senderId, text: msgObj.content, type: 'text-image', llmContent }); break;
                        case 'sticker': if (character?.aiStickers?.length > 0) addMessage({ sender: senderId, type: 'sticker', stickerUrl: character.aiStickers[Math.floor(Math.random() * character.aiStickers.length)], llmContent }); break;
                        case 'transfer': addMessage({ sender: senderId, type: 'transfer', transferAmount: msgObj.amount, transferMemo: msgObj.memo, transferCoverUrl: `https://source.unsplash.com/400x220/?gift,love`, transferStatus: 'pending', llmContent }); break;
                        case 'video-call-request': if(currentChat.type === 'direct') handleIncomingVideoCall(msgObj.content); break;
                        case 'post_moment': if(character) { addMomentByAI(character.id, { content: msgObj.content, imageUrl: `https://source.unsplash.com/500x500/?${encodeURIComponent(msgObj.image_query || 'scenery')}` }); addMessage({sender: 'system', text: `${character.config.characterName}がモーメンツを投稿しました`}); } break;
                        case 'vote': handleAiVote(msgObj); break;
                    }
                }, index * 1200);
            });
        };
        
        const triggerAiMomentPostAfterTransfer = async (amount) => {
            const character = getCurrentCharacter();
            if (!character) return;
            const { config } = character;
            if (!config.apiBaseUrl || !config.apiKey || !config.model) return;

            const prompt = `[役割]: あなたは${config.characterName}です。\n[状況]: ユーザーから${amount}円の送金を受け取りました。\n[タスク]: この嬉しい出来事について、あなたの性格になりきって、短いSNS（モーメンツ）の投稿を作成してください。\n[出力形式]: {"type": "post_moment", "content": "投稿テキスト", "image_query": "投稿に合う画像のキーワード"}`;
            const messages = [{ role: 'system', content: DEFAULT_SYSTEM_PROMPT }, { role: 'user', content: prompt }];
            try {
                const response = await fetch(`${config.apiBaseUrl}/v1/chat/completions`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${config.apiKey}` }, body: JSON.stringify({ model: config.model, messages }) });
                if (!response.ok) throw new Error(await response.text());
                const data = await response.json();
                if (data?.choices?.[0]?.message?.content) {
                    processAiResponse(data.choices[0].message.content);
                }
            } catch(e) { console.error("Failed to post moment after transfer:", e); }
        };

        const acknowledgeTransfer = (msgId) => {
            const chatData = getCurrentChatData();
            if(!chatData) return;
            const transferMsg = chatData.chatHistory.find(m => String(m.id) === String(msgId));
            if (transferMsg && transferMsg.sender !== 'user' && transferMsg.transferStatus !== 'received') {
                if (confirm('この送金を受け取りますか？')) {
                    transferMsg.transferStatus = 'received';
                    saveAllData();
                    renderAllMessages();
                }
            }
        };

        const toggleMultiSelectMode = (enable) => {
            isMultiSelectMode = enable;
            elements.messagesContainer.classList.toggle('multi-select-mode', enable);
            elements.deleteToolbar.classList.toggle('show', enable);
            elements.inputArea.style.visibility = enable ? 'hidden' : 'visible';
            if (!enable) {
                selectedMessageIds = [];
                document.querySelectorAll('.message.selected').forEach(el => el.classList.remove('selected'));
            }
        };
        const toggleMessageSelection = (messageElement) => {
            const id = messageElement.dataset.id;
            if (!id) return;
            messageElement.classList.toggle('selected');
            const index = selectedMessageIds.indexOf(id);
            if (index > -1) { selectedMessageIds.splice(index, 1); } else { selectedMessageIds.push(id); }
            elements.deleteInfo.textContent = selectedMessageIds.length > 0 ? `${selectedMessageIds.length} 件選択中` : '';
            if (selectedMessageIds.length === 0) { toggleMultiSelectMode(false); }
        };
        const deleteSelectedMessages = () => {
            const chatData = getCurrentChatData();
            if(!chatData || selectedMessageIds.length === 0) return;
            chatData.chatHistory = chatData.chatHistory.filter(msg => !selectedMessageIds.includes(String(msg.id)));
            saveAllData();
            renderAllMessages();
            toggleMultiSelectMode(false);
        };
        
        const toggleActionPanel = (forceClose = false) => { isActionPanelOpen = forceClose ? false : !isActionPanelOpen; elements.actionPanel.classList.toggle('show', isActionPanelOpen); elements.actionBtn.style.transform = isActionPanelOpen ? 'rotate(45deg)' : 'rotate(0)'; };
        let onFeatureModalSubmit = null;
        const openFeatureModal = (title, bodyHtml, submitText, onSubmit) => { elements.featureModalTitle.textContent = title; elements.featureModalBody.innerHTML = bodyHtml; elements.featureModalSubmitBtn.style.display = onSubmit ? 'inline-block' : 'none'; if(onSubmit){ elements.featureModalSubmitBtn.textContent = submitText; onFeatureModalSubmit = onSubmit; } elements.featureModal.classList.add('show'); };
        
        const handleTextImageSend = () => { openFeatureModal('画像を説明する', `<div class="form-group"><label for="text-image-input">画像の説明を入力してください:</label><textarea id="text-image-input" rows="4"></textarea></div>`, '送信', () => { const text = getEl('text-image-input').value.trim(); if (text) { handleUserAction({ sender: 'user', type: 'text-image', text, llmContent: `[写真を見せた。写真の内容: ${text}]` }); closeModal(elements.featureModal); } }); };
        const handleVoiceSend = () => { openFeatureModal('ボイスメッセージを送信', `<div class="form-group"><label for="voice-text-input">「話したい」内容を入力してください:</label><textarea id="voice-text-input" rows="4"></textarea></div>`, '送信', () => { const text = getEl('voice-text-input').value.trim(); if (text) { handleUserAction({ sender: 'user', type: 'voice', text, voiceDuration: `0:${Math.max(1, Math.round(text.length / 5)).toString().padStart(2, '0')}`, llmContent: `[ボイスメッセージを送信した。内容は: ${text}]` }); closeModal(elements.featureModal); } }); };
        const handleTransferSend = () => { let tempCover = "https://images.unsplash.com/photo-1593697821028-7655f8458345?q=80&w=400"; openFeatureModal('送金', `<div class="form-group"><label>送金カバー</label><img id="transfer-preview" src="${tempCover}" style="width:100%; height:110px; object-fit:cover; border-radius:8px; margin-bottom:10px; cursor:pointer;"></div><div class="form-group"><label for="transfer-amount">金額</label><input type="number" id="transfer-amount" placeholder="0.00"></div><div class="form-group"><label for="transfer-memo">メモ</label><input type="text" id="transfer-memo" placeholder="（任意）"></div>`, '送信', () => { const amount = getEl('transfer-amount').value; if (amount > 0) { const memo = getEl('transfer-memo').value.trim(); handleUserAction({ sender: 'user', type: 'transfer', transferAmount: parseFloat(amount).toFixed(2), transferMemo: memo, transferCoverUrl: tempCover, transferStatus: 'pending', llmContent: `[${amount}円を送金した。メモ: ${memo}]` }); closeModal(elements.featureModal); } }); getEl('transfer-preview').onclick = () => elements.transferCoverInput.click(); elements.transferCoverInput.onchange = (e) => handleFileUpload(e.target.files[0], (d) => { tempCover = d; getEl('transfer-preview').src = d; }); };
        const handleStickerSend = () => { if (currentChat.type !== 'direct') {alert('群聊ではまだスタンプを送信できません。'); return;} const character = getCurrentCharacter(); if(!character) return; let galleryHtml = '<p style="text-align:center;color:#999">スタンプがありません。設定で追加してください。</p>'; if (character.userStickers.length > 0) galleryHtml = character.userStickers.map(url => `<img src="${url}" data-sticker-url="${url}" alt="sticker">`).join(''); openFeatureModal('スタンプを選択', `<div id="sticker-gallery">${galleryHtml}</div>`, null, null); getEl('sticker-gallery').onclick = e => { if (e.target.tagName === 'IMG') { handleUserAction({ sender: 'user', type: 'sticker', stickerUrl: e.target.dataset.stickerUrl, llmContent: '[スタンプを送信した]' }); closeModal(elements.featureModal); } }; };
        
        // --- Video Call Logic ---
        const addVideoChatMessageToUI = (msg) => { const msgEl = document.createElement('div'); msgEl.className = `video-chat-message ${msg.sender === 'user' ? 'user' : 'ai'}`; msgEl.innerHTML = msg.text.replace(/\*(.*?)\*/g, '<i>$1</i>'); elements.videoChatLog.appendChild(msgEl); scrollToBottom(elements.videoChatLog); };
        const triggerVideoCallAIResponse = async () => { if (currentChat.type !== 'direct') return; const character = getCurrentCharacter(); if(!character) return; const { config, chatHistory } = character; const {apiBaseUrl, apiKey, model, characterPrompt} = config; if (!apiBaseUrl || !apiKey || !model) return; elements.videoStatusText.textContent = `${config.characterName}が入力中...`; const videoCallSystemPrompt = `${characterPrompt}\n[現在の状況: ビデオ通話中]\n[特別指示]\n- あなたのすべての返信は純粋なテキストでなければならず、「*表情や行動* 会話内容」の形式に厳密に従ってください。\n- 会話内容は短めに、20〜30字程度にしてください。`; const videoHistory = chatHistory.filter(m => m.isVideoCallMessage); const messagesPayload = [{ role: 'system', content: videoCallSystemPrompt }, ...videoHistory.slice(-10).map(m => ({ role: m.sender === 'user' ? 'user' : 'assistant', content: m.text }))]; try { const response = await fetch(`${apiBaseUrl}/v1/chat/completions`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify({ model: model, messages: messagesPayload }) }); if (!response.ok) { throw new Error(`HTTP Error ${response.status}: ${await response.text()}`); } const responseData = await response.json(); if (responseData?.choices?.[0]?.message) { addMessage({ sender: character.id, text: responseData.choices[0].message.content, type: 'text', isVideoCallMessage: true }); elements.videoStatusText.textContent = "通話中"; } else { throw new Error('ビデオ通話のAPIレスポンス形式が無効です。'); } } catch (error) { addMessage({ sender: character.id, text: `(接続エラー)`, type: 'text', isVideoCallMessage: true }); elements.videoStatusText.textContent = "接続エラー"; } };
        const startVideoCall = () => { if (currentChat.type !== 'direct') return; const character = getCurrentCharacter(); if(!character) return; const { config } = character; if (!config.apiBaseUrl || !config.apiKey || !config.model) { alert('先に設定でAPI情報を入力してください。'); return; } isVideoCallActive = true; elements.videoMainView.src = config.aiAvatar; elements.videoSelfView.src = config.userAvatar; elements.videoCharacterAvatar.src = config.aiAvatar; elements.videoCharacterName.textContent = config.characterName; elements.videoStatusText.textContent = "発信中..."; elements.videoChatLog.innerHTML = ''; elements.videoControls.innerHTML = `<button class="video-btn decline"><svg viewBox="0 0 24 24"><path d="M12 9c-1.6 0-3.15.25-4.62.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.1-2.69 1.8l-1.1-1.1c.99-.99 2.1-1.82 3.31-2.48C7.06 10.72 9.03 10 12 10c.05 0 .1 0 .16.01l2.4-2.4C13.84 7.23 12.95 7 12 7c-4.97 0-9 4.03-9 9H0c0-6.08 4.92-11 11-11 .34 0 .67.02 1 .05l-1.43 1.43C12.21 9.02 12.11 9 12 9zM1.39 4.22l2.27 2.27C2.63 7.62 2 8.91 2 10.31v3.1c1.53-.69 3.23-1.14 5.08-1.28l3.43 3.43c-3.11.3-6.01 1.54-7.96 3.4l1.41 1.41c2.19-2.19 5.08-3.48 8.04-3.83l2.84 2.84c.32.32.88.1.88-.36V13.5c.75-.24 1.46-.56 2.12-.95l2.07 2.07 1.41-1.41L2.81 2.81 1.39 4.22zM21 5h-2.59l4.59 4.59-1.41 1.41L12 1.41 2.81 11.59l-1.41-1.41L6 5.59V5h2v.59l4-4 4 4V5h2v3.41l2.29-2.29C23.36 5.64 22.25 5 21 5z"/></svg></button>`; elements.videoControls.querySelector('.decline').onclick = endVideoCall; elements.videoCallOverlay.classList.add('show'); addMessage({ sender: 'system', type: 'text', text: 'ビデオ通話を発信しました' }); addMessage({ sender: 'user', text: '[ビデオ通話を発信]', type: 'text', isVideoCallMessage: true }); triggerVideoCallAIResponse(); };
        const handleIncomingVideoCall = (text) => { if (currentChat.type !== 'direct') return; const { config } = getCurrentCharacter(); elements.videoMainView.src = config.aiAvatar; elements.videoSelfView.src = config.userAvatar; elements.videoCharacterAvatar.src = config.aiAvatar; elements.videoCharacterName.textContent = config.characterName; elements.videoStatusText.textContent = text || "ビデオ通話の着信..."; elements.videoChatLog.innerHTML = ''; elements.videoControls.innerHTML = `<button class="video-btn accept"><svg viewBox="0 0 24 24"><path d="M20.01 15.38c-1.23 0-2.42-.2-3.53-.56-.35-.12-.74-.03-1.01.24l-1.57 1.97c-2.83-1.35-5.21-3.72-6.56-6.56l1.97-1.57c.27-.27.36-.66.24-1.01-.37-1.11-.56-2.3-.56-3.53 0-.54-.45-.99-.99-.99H4.19c-.55 0-.99.45-.99.99 0 9.02 7.38 16.4 16.4 16.4.55 0 .99-.45.99-.99v-3.47c0-.54-.45-.99-.99-.99z"/></svg></button> <button class="video-btn decline"><svg viewBox="0 0 24 24"><path d="M12 9c-1.6 0-3.15.25-4.62.72v3.1c0 .39-.23.74-.56.9-.98.49-1.87 1.1-2.69 1.8l-1.1-1.1c.99-.99 2.1-1.82 3.31-2.48C7.06 10.72 9.03 10 12 10c.05 0 .1 0 .16.01l2.4-2.4C13.84 7.23 12.95 7 12 7c-4.97 0-9 4.03-9 9H0c0-6.08 4.92-11 11-11 .34 0 .67.02 1 .05l-1.43 1.43C12.21 9.02 12.11 9 12 9zM1.39 4.22l2.27 2.27C2.63 7.62 2 8.91 2 10.31v3.1c1.53-.69 3.23-1.14 5.08-1.28l3.43 3.43c-3.11.3-6.01 1.54-7.96 3.4l1.41 1.41c2.19-2.19 5.08-3.48 8.04-3.83l2.84 2.84c.32.32.88.1.88-.36V13.5c.75-.24 1.46-.56 2.12-.95l2.07 2.07 1.41-1.41L2.81 2.81 1.39 4.22zM21 5h-2.59l4.59 4.59-1.41 1.41L12 1.41 2.81 11.59l-1.41-1.41L6 5.59V5h2v.59l4-4 4 4V5h2v3.41l2.29-2.29C23.36 5.64 22.25 5 21 5z"/></svg></button>`; elements.videoControls.querySelector('.accept').onclick = () => { isVideoCallActive = true; elements.videoStatusText.textContent = "通話に接続しました"; elements.videoControls.innerHTML = elements.videoControls.innerHTML.replace(/<button class="video-btn accept">.*?<\/button>/, ''); addMessage({sender:'system', type:'text', text:'ビデオ通話に応答しました'}); addMessage({sender:'user', text:'[ビデオ通話に応答]', type:'text', isVideoCallMessage: true }); triggerVideoCallAIResponse(); }; elements.videoControls.querySelector('.decline').onclick = () => { elements.videoCallOverlay.classList.remove('show'); addMessage({sender:'system', type:'text', text:'ビデオ通話を拒否しました'}); }; elements.videoCallOverlay.classList.add('show'); };
        const endVideoCall = () => { isVideoCallActive = false; elements.videoCallOverlay.classList.remove('show'); addMessage({ sender: 'system', type: 'text', text: 'ビデオ通話が終了しました' }); renderAllMessages(); };
        
        const showMindVoice = async () => { if (currentChat.type !== 'direct') return; const character = getCurrentCharacter(); if(!character) return; const { config, chatHistory } = character; const {apiBaseUrl, apiKey, model, characterPrompt} = config; if (!apiBaseUrl || !apiKey || !model) return; elements.mindVoiceContent.textContent = '思考中...'; elements.mindVoiceModal.classList.add('show'); const mindVoiceSystemPrompt = `${characterPrompt}\n[現在のタスク: 内心表現]\n[特別指示]\n- 最近の会話に基づいて、今、心の中で何を考えていますか？\n- 日記のように、今の生の、フィルターのかかっていない考えを書き出してください。一人称で記述してください。`; const messagesPayload = [{ role: 'system', content: mindVoiceSystemPrompt }, ...chatHistory.slice(-config.memorySize).map(m => ({ role: m.sender === 'user' ? 'user' : 'assistant', content: m.llmContent || m.text }))]; try { const response = await fetch(`${apiBaseUrl}/v1/chat/completions`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify({ model, messages: messagesPayload }) }); if (!response.ok) { throw new Error(`HTTP Error ${response.status}: ${await response.text()}`); } const responseData = await response.json(); if (responseData?.choices?.[0]?.message) { elements.mindVoiceContent.textContent = responseData.choices[0].message.content; } else { throw new Error('APIから有効な心声が返されませんでした。'); } } catch (error) { elements.mindVoiceContent.textContent = `心声の読み取りに失敗しました: ${error.message}`; } };
        const openStickerManager = (context) => { if (currentChat.type !== 'direct') return; const character = getCurrentCharacter(); if(!character) return; let stickerManagementContext = context; const currentStickers = context === 'user' ? character.userStickers : character.aiStickers; let galleryHtml = '<p style="text-align:center; color:#999;">下のボタンで追加、追加済みのスタンプをクリックで削除できます。</p>' + currentStickers.map(url => `<img src="${url}" data-sticker-url="${url}" alt="sticker">`).join(''); openFeatureModal(context === 'user' ? '自分のスタンプ管理' : '彼のスタンプ管理', `<div id="sticker-gallery" style="margin-bottom:15px;">${galleryHtml}</div><button id="add-stickers-btn" class="file-input-label" style="text-align:center; width:100%;">ライブラリから一括追加</button>`, '完了', () => closeModal(elements.featureModal)); getEl('add-stickers-btn').onclick = () => elements.stickerUploadInput.click(); getEl('sticker-gallery').onclick = e => { if (e.target.tagName === 'IMG') { if(confirm('このスタンプを削除しますか？')) { const urlToDelete = e.target.dataset.stickerUrl; if(stickerManagementContext === 'user') character.userStickers = character.userStickers.filter(url => url !== urlToDelete); else character.aiStickers = character.aiStickers.filter(url => url !== urlToDelete); saveAllData(); e.target.remove(); } } }; elements.stickerUploadInput.onchange = (e) => { Array.from(e.target.files).forEach((file, i, arr) => { handleFileUpload(file, (result) => { if (stickerManagementContext === 'user') character.userStickers.push(result); else character.aiStickers.push(result); if (i === arr.length - 1) { saveAllData(); alert(`${arr.length}個のスタンプが追加されました！`); closeModal(elements.featureModal); openStickerManager(stickerManagementContext); } }); }); e.target.value = ''; }; };

        // --- Chat Management Logic (Characters & Groups) ---
        const openChatManager = () => {
            const bodyHtml = `
                <div class="chat-manager-tabs">
                    <div class="chat-manager-tab active" data-tab="direct">单人聊天</div>
                    <div class="chat-manager-tab" data-tab="group">群组聊天</div>
                </div>
                <div id="direct-chat-list" class="chat-manager-content active">
                    <div class="chat-list">
                        ${characterSets.map(char => `
                            <div class="chat-item ${currentChat.type === 'direct' && char.id === currentChat.id ? 'active' : ''}" data-type="direct" data-id="${char.id}">
                                <img src="${char.config.aiAvatar}" alt="${char.config.characterName}">
                                <span class="name">${char.config.characterName}</span>
                                <button class="delete-btn" data-type="direct" data-id="${char.id}" title="キャラクター削除">&times;</button>
                            </div>
                        `).join('')}
                    </div>
                    <button id="add-character-btn" class="add-new-btn">新規キャラクター作成</button>
                </div>
                <div id="group-chat-list" class="chat-manager-content">
                     <div class="chat-list">
                        ${groupChats.map(group => `
                            <div class="chat-item ${currentChat.type === 'group' && group.id === currentChat.id ? 'active' : ''}" data-type="group" data-id="${group.id}">
                                <img src="${group.avatar}" alt="${group.name}">
                                <span class="name">${group.name}</span>
                                <button class="delete-btn" data-type="group" data-id="${group.id}" title="群組削除">&times;</button>
                            </div>
                        `).join('')}
                    </div>
                    <button id="add-group-btn" class="add-new-btn">新規群聊作成</button>
                </div>
            `;
            openFeatureModal('チャット切り替え', bodyHtml, null, null);

            const modalBody = getEl('feature-modal-body');
            modalBody.querySelectorAll('.chat-manager-tab').forEach(tab => {
                tab.onclick = () => {
                    modalBody.querySelector('.chat-manager-tab.active').classList.remove('active');
                    tab.classList.add('active');
                    modalBody.querySelector('.chat-manager-content.active').classList.remove('active');
                    getEl(tab.dataset.tab + '-chat-list').classList.add('active');
                };
            });
            
            modalBody.onclick = (e) => {
                const item = e.target.closest('.chat-item');
                const deleteBtn = e.target.closest('.delete-btn');
                const addCharBtn = e.target.closest('#add-character-btn');
                const addGroupBtn = e.target.closest('#add-group-btn');

                if (deleteBtn) {
                    e.stopPropagation();
                    handleDeleteChat(deleteBtn.dataset.type, deleteBtn.dataset.id);
                } else if (item) {
                    loadChat(item.dataset.type, item.dataset.id);
                    closeModal(elements.featureModal);
                } else if (addCharBtn) {
                    const newChar = createNewCharacterObject();
                    characterSets.push(newChar);
                    saveAllData();
                    loadChat('direct', newChar.id);
                    closeModal(elements.featureModal);
                    elements.settingsModal.classList.add('show'); 
                } else if (addGroupBtn) {
                    openCreateGroupModal();
                }
            };
        };

        const openCreateGroupModal = () => {
            let tempGroupAvatar = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0iI2EwYTBiMyI+PHBhdGggZD0iTTExIDEyYy0uNTUgMC0xLS40NS0xLTFzLjQ1LTEgMS0xIDEgLjQ1IDEgMXMtLjQ1IDEtMSAxem00IDBjLS41NSAwLTEtLjQ1LTEtMXMuNDUtMSAxLTEgMSAuNDUgMSAxcy0uNDUgMS0xIDF6bS04IDBjLS41NSAwLTEtLjQ1LTEtMXMuNDUtMSAxLTEgMSAuNDUgMSAxcy0uNDUgMS0xIDF6bTEwLThINWMtMS4xIDAtMiAuOS0yIDJ2MTRsNC00aDEyYzEuMSAwIDItLjkgMi0yVjZjMC0xLjEtLjktMi0yLTJ6bTAtMTJoMTJjMS4xIDAgMiAuOSAyIDJ2MTBsMiAydjQtMmMwLTEuMS0uOS0yLTItMkg2bC00IDRWMnYyaDR6Ii8+PC9zdmc+';
            const memberSelectionHtml = characterSets.map(c => `
                <label class="member-select-item">
                    <input type="checkbox" name="group-members" value="${c.id}">
                    <img src="${c.config.aiAvatar}" style="width: 30px; height: 30px; border-radius: 6px;">
                    <span>${c.config.characterName}</span>
                </label>
            `).join('');

            const bodyHtml = `
                <div class="form-group avatar-upload-group" style="justify-content:center; flex-direction:column;">
                    <img id="group-avatar-preview" src="${tempGroupAvatar}" class="avatar-preview" style="width:80px;height:80px;border-radius:12px;cursor:pointer;">
                    <label for="group-avatar-upload-input" class="file-input-label" style="margin-top:10px;">群头像を選択</label>
                </div>
                <div class="form-group"><label for="new-group-name">群名称</label><input type="text" id="new-group-name" placeholder="楽しい群聊"></div>
                <div class="form-group"><label>メンバーを選択</label><div id="create-group-members">${memberSelectionHtml}</div></div>
            `;
            openFeatureModal('新規群聊作成', bodyHtml, '作成', () => {
                const name = getEl('new-group-name').value.trim() || '楽しい群聊';
                const selectedMembers = Array.from(document.querySelectorAll('input[name="group-members"]:checked')).map(cb => cb.value);
                if (selectedMembers.length < 1) {
                    alert('少なくとも一人のメンバーを選択してください。');
                    return;
                }
                const newGroup = createNewGroupObject(name, tempGroupAvatar, selectedMembers);
                groupChats.push(newGroup);
                saveAllData();
                loadChat('group', newGroup.id);
                closeModal(elements.featureModal);
            });
            
            getEl('group-avatar-preview').onclick = () => elements.groupAvatarUploadInput.click();
            elements.groupAvatarUploadInput.onchange = e => handleFileUpload(e.target.files[0], d => {
                tempGroupAvatar = d;
                getEl('group-avatar-preview').src = d;
            });
        };

        const handleDeleteChat = (type, idToDelete) => {
            if (type === 'direct') {
                 if (characterSets.length <= 1) {
                    alert("少なくとも一人のキャラクターは残す必要があります。");
                    return;
                }
                const charToDelete = characterSets.find(c => c.id === idToDelete);
                if (confirm(`キャラクター「${charToDelete.config.characterName}」を本当に削除しますか？`)) {
                    characterSets = characterSets.filter(c => c.id !== idToDelete);
                    if (currentChat.id === idToDelete) {
                        loadChat('direct', characterSets[0].id);
                    }
                    saveAllData();
                    closeModal(elements.featureModal);
                }
            } else { // group
                const groupToDelete = groupChats.find(g => g.id === idToDelete);
                if (confirm(`群聊「${groupToDelete.name}」を本当に削除しますか？`)) {
                    groupChats = groupChats.filter(g => g.id !== idToDelete);
                     if (currentChat.id === idToDelete) {
                        loadChat('direct', characterSets[0].id);
                    }
                    saveAllData();
                    closeModal(elements.featureModal);
                }
            }
        };

        // --- Moments (朋友圈) Logic ---
        const addMomentByAI = (characterId, momentData) => { const character = characterSets.find(c => c.id === characterId); if(!character) return; const newMoment = { id: generateId('moment'), senderId: character.id, timestamp: getFullTimestamp(), likes: [], comments: [], ...momentData }; character.moments.unshift(newMoment); saveAllData(); };
        const addMomentByUser = async (momentData) => { const newMoment = { id: generateId('moment'), senderId: 'user', timestamp: getFullTimestamp(), likes: [], comments: [], ...momentData }; userMomentsProfile.posts.unshift(newMoment); saveAllData(); openMoments(); await triggerAiMomentComment(newMoment.content); };
        const triggerAiMomentComment = async (postContent) => { if (currentChat.type !== 'direct') return; const character = getCurrentCharacter(); if (!character) return; const { config } = character; if (!config.apiBaseUrl || !config.apiKey || !config.model) return; const prompt = `[役割]: あなたは${config.characterName}です。\n[状況]: ユーザーが新しいモーメントを投稿しました。\n[ユーザーの投稿内容]: "${postContent}"\n[タスク]: あなたの人格になりきって、この投稿に気の利いたコメントをしてください。\n[出力形式]: {"type": "moment_comment", "comment_text": "あなたのコメント"}`; const messages = [{ role: 'system', content: DEFAULT_SYSTEM_PROMPT }, { role: 'user', content: prompt }]; try { const response = await fetch(`${config.apiBaseUrl}/v1/chat/completions`, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${config.apiKey}` }, body: JSON.stringify({ model: config.model, messages }) }); if (!response.ok) { console.error("AI comment failed: ", await response.text()); return; } const responseData = await response.json(); if (responseData?.choices?.[0]?.message?.content) { processAiResponse(responseData.choices[0].message.content); } } catch (error) { console.error("モーメントコメントのAIトリガーエラー:", error); } };
        const renderMoments = () => { if (currentChat.type !== 'direct') { elements.momentsFeed.innerHTML = '<p style="text-align:center; padding:20px;">群聊ではモーメンツを利用できません。</p>'; return; } const character = getCurrentCharacter(); if(!character) return; elements.momentsCoverArea.style.backgroundImage = `url(${userMomentsProfile.cover})`; elements.momentsUserAvatar.src = userMomentsProfile.avatar; elements.momentsUserName.textContent = userMomentsProfile.name; const allPosts = [ ...character.moments.map(m => ({ ...m, senderType: 'ai' })), ...userMomentsProfile.posts.map(p => ({ ...p, senderType: 'user' })) ].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); elements.momentsFeed.innerHTML = allPosts.map(post => { const senderIsUser = post.senderType === 'user'; const postChar = !senderIsUser ? characterSets.find(c => c.id === post.senderId) : null; const senderName = senderIsUser ? userMomentsProfile.name : postChar?.config.characterName || '不明'; const senderAvatar = senderIsUser ? userMomentsProfile.avatar : postChar?.config.aiAvatar || ''; return ` <div class="moment-post" data-moment-id="${post.id}" data-sender-type="${senderIsUser ? 'user' : 'ai'}" data-sender-id="${post.senderId}"> <img src="${senderAvatar}" alt="avatar" class="moment-avatar"> <div class="moment-body"> <div class="moment-username">${senderName}</div> <div class="moment-content">${post.content.replace(/\n/g, '<br>')}</div> ${post.imageUrl ? `<img src="${post.imageUrl}" alt="moment image" class="moment-image">` : ''} <div class="moment-footer"> <span class="moment-timestamp">${post.timestamp}</span> <div class="moment-actions"> <button class="like-btn ${post.likes.includes('user') ? 'liked' : ''}"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg> <span class="like-count">${post.likes.length > 0 ? post.likes.length : ''}</span> </button> <button class="comment-btn"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H6l-2 2V4h16v12z"/></svg> </button> </div> </div> <div class="moment-comments"> ${post.comments.map(c => { const commenterChar = c.sender !== 'user' ? characterSets.find(char => char.id === c.sender) : null; const commenterName = c.sender === 'user' ? userMomentsProfile.name : commenterChar?.config.characterName || '不明'; return `<div class="comment"><span class="comment-user">${commenterName}: </span><span>${c.text}</span></div>`; }).join('')} </div> <form class="comment-input-form" style="display: none;"> <input type="text" class="comment-input" placeholder="コメントを追加..."> <button type="submit">送信</button> </form> </div> </div> `}).join(''); };
        const openMoments = () => { renderMoments(); elements.momentsOverlay.classList.add('show'); };
        const handleMomentsInteraction = (e) => { const likeBtn = e.target.closest('.like-btn'); const commentBtn = e.target.closest('.comment-btn'); const commentForm = e.target.closest('.comment-input-form'); const postEl = e.target.closest('.moment-post'); if (!postEl) return; const momentId = postEl.dataset.momentId; const senderType = postEl.dataset.senderType; const senderId = postEl.dataset.senderId; const postSource = senderType === 'user' ? userMomentsProfile.posts : characterSets.find(c => c.id === senderId)?.moments; if (!postSource) return; const moment = postSource.find(m => m.id === momentId); if (!moment) return; if (likeBtn) { const likeIndex = moment.likes.indexOf('user'); if (likeIndex > -1) { moment.likes.splice(likeIndex, 1); } else { moment.likes.push('user'); } saveAllData(); renderMoments(); } if (commentBtn) { const form = postEl.querySelector('.comment-input-form'); if (form) form.style.display = form.style.display === 'none' ? 'flex' : 'none'; } if (commentForm) { e.preventDefault(); const input = commentForm.querySelector('.comment-input'); const text = input.value.trim(); if (text) { moment.comments.push({ sender: 'user', text }); input.value = ''; saveAllData(); renderMoments(); } } };
        const openPostMomentModal = () => { let tempImage = null; const bodyHtml = ` <div class="form-group"> <textarea id="new-moment-text" rows="5" placeholder="今なにしてる？"></textarea> </div> <div class="form-group"> <label for="moment-post-image-input" class="file-input-label">写真を追加</label> <img id="new-moment-preview" src="" style="max-width: 100px; max-height: 100px; border-radius: 8px; margin-top: 10px; display: none;"> </div> `; openFeatureModal('新規投稿', bodyHtml, '投稿', () => { const text = getEl('new-moment-text').value.trim(); if(text || tempImage) { addMomentByUser({ content: text, imageUrl: tempImage }); closeModal(elements.featureModal); } }); const preview = getEl('new-moment-preview'); getEl('feature-modal-body').querySelector('label').onclick = () => elements.momentPostImageInput.click(); elements.momentPostImageInput.onchange = e => handleFileUpload(e.target.files[0], (dataUrl) => { tempImage = dataUrl; preview.src = dataUrl; preview.style.display = 'block'; }); };
        
        // --- Poll Logic ---
        const openCreatePollModal = () => { const bodyHtml = ` <div class="form-group"><label for="poll-question">投票の質問</label><input type="text" id="poll-question" placeholder="夕食は何がいい？"></div> <div class="form-group"><label>選択肢 (1行に1つ)</label><textarea id="poll-options" rows="4" placeholder="ピザ\n寿司\nタコス"></textarea></div> `; openFeatureModal('投票を作成', bodyHtml, '作成', () => { const question = getEl('poll-question').value.trim(); const options = getEl('poll-options').value.split('\n').map(o => o.trim()).filter(o => o); if (question && options.length >= 2) { const pollId = generateId('poll'); handleUserAction({ sender: 'user', type: 'poll', pollId, question, options, llmContent: `[ユーザーが投票を作成しました。質問: "${question}", 選択肢: ${options.join(", ")}]` }); closeModal(elements.featureModal); } else { alert('質問と少なくとも2つの選択肢を入力してください。'); } }); };
        const renderPoll = (msg) => { if (currentChat.type !== 'group') return ''; const group = getCurrentGroup(); if (!group) return ''; const pollData = group.polls.find(p => p.pollId === msg.pollId); if (!pollData) return `<p>投票データの読み込みに失敗しました。</p>`; const totalVotes = Object.values(pollData.votes).flat().length; const userHasVoted = Object.values(pollData.votes).flat().includes('user'); const optionsHtml = pollData.options.map(option => { const voters = pollData.votes[option] || []; const voteCount = voters.length; const percentage = totalVotes > 0 ? (voteCount / totalVotes * 100).toFixed(0) : 0; const voterAvatars = voters.map(voterId => { const avatarSrc = voterId === 'user' ? userMomentsProfile.avatar : characterSets.find(c => c.id === voterId)?.config.aiAvatar; return avatarSrc ? `<img src="${avatarSrc}" class="poll-voter-avatar">` : ''; }).join(''); return ` <div class="poll-option"> <div class="poll-option-label">${option} (${voteCount}票)</div> <div class="poll-progress-bar"> <div class="poll-progress-fill" style="width: ${percentage}%;"> <span class="poll-percentage">${percentage}%</span> </div> </div> <div class="poll-voters">${voterAvatars}</div> ${!userHasVoted ? `<button class="poll-vote-btn" data-poll-id="${pollData.pollId}" data-option="${option}">この選択肢に投票</button>` : ''} </div>`; }).join(''); return `<div class="poll-question">${pollData.question}</div>${optionsHtml}`; };
        const handleUserVote = (pollId, option) => { if (currentChat.type !== 'group') return; const group = getCurrentGroup(); if (!group) return; const poll = group.polls.find(p => p.pollId === pollId); if (!poll || poll.status === 'closed') return; Object.keys(poll.votes).forEach(key => { poll.votes[key] = poll.votes[key].filter(v => v !== 'user'); }); if (!poll.votes[option]) poll.votes[option] = []; poll.votes[option].push('user'); saveAllData(); renderAllMessages(); handleUserAction({ sender: 'user', type: 'text', text: `[投票しました: 「${option}」]`, llmContent: `[ユーザーが投票しました。選択: "${option}"]` }); };
        const handleAiVote = (voteAction) => { if (currentChat.type !== 'group') return; const group = getCurrentGroup(); if (!group) return; const poll = group.polls.find(p => p.pollId === voteAction.pollId); const voterId = voteAction.senderId; const option = voteAction.option; if (!poll || !voterId || !option || poll.status === 'closed' || !poll.options.includes(option)) return; Object.keys(poll.votes).forEach(key => { poll.votes[key] = poll.votes[key].filter(v => v !== voterId); }); if (!poll.votes[option]) poll.votes[option] = []; poll.votes[option].push(voterId); saveAllData(); renderAllMessages(); };

        // --- Data Import/Export ---
        const exportData = () => { if (currentChat.type === 'direct') saveCurrentCharacterSettings(); const data = localStorage.getItem('aiBoyfriendBackup_v2'); const blob = new Blob([data], {type: 'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `ai_boyfriend_backup_${new Date().toISOString().slice(0,10)}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); alert('全データがエクスポートされました！'); };
        const importData = () => { if(confirm('現在の全データを上書きして、ファイルからインポートしますか？')) { elements.importDataInput.click(); } };
        const handleDataImport = (event) => { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const data = e.target.result; const parsed = JSON.parse(data); if (parsed.characterSets && parsed.currentChat) { localStorage.setItem('aiBoyfriendBackup_v2', data); alert('インポート成功！ページをリロードします。'); location.reload(); } else { alert('無効なファイルです。'); } } catch (error) { alert(`エラー: ${error.message}`); } }; reader.readAsText(file); elements.importDataInput.value = ''; };

        const setupEventListeners = () => {
            elements.settingsBtn.onclick = () => {
                if (currentChat.type === 'direct') {
                    const character = getCurrentCharacter();
                    if(character) applySettings(character.config);
                    elements.characterSettingsSection.style.display = 'block';
                    elements.dangerZoneSection.style.display = 'block';
                    elements.settingsModal.classList.add('show');
                }
            };
            elements.closeSettingsBtn.onclick = () => closeModal(elements.settingsModal);
            elements.saveSettingsBtn.onclick = () => { saveCurrentCharacterSettings(); alert('設定が保存されました！'); closeModal(elements.settingsModal); };
            
            elements.sendBtn.onclick = () => { const text = elements.messageInput.value.trim(); if (!text) return; handleUserAction({ sender: 'user', type: 'text', text, llmContent: text }); elements.messageInput.value = ''; autoResizeTextarea(); };
            elements.messageInput.onkeydown = (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); elements.sendBtn.click(); } };
            
            elements.videoSendBtn.onclick = () => { const text = elements.videoMessageInput.value.trim(); if (!text) return; addMessage({ sender: 'user', text: text, type: 'text', isVideoCallMessage: true }); elements.videoMessageInput.value = ''; triggerVideoCallAIResponse(); };
            elements.videoMessageInput.onkeydown = (e) => { if (e.key === 'Enter') { e.preventDefault(); elements.videoSendBtn.click(); } };

            elements.mindVoiceCloseBtn.onclick = () => elements.mindVoiceModal.classList.remove('show');
            elements.actionBtn.onclick = () => toggleActionPanel();
            elements.actionShowMoments.onclick = () => { openMoments(); toggleActionPanel(true); };
            elements.actionSendTextImage.onclick = () => { handleTextImageSend(); toggleActionPanel(true); };
            elements.actionSendRealImage.onclick = () => { elements.realImageUploadInput.click(); toggleActionPanel(true); };
            elements.actionSendVoice.onclick = () => { handleVoiceSend(); toggleActionPanel(true); };
            elements.actionSendTransfer.onclick = () => { handleTransferSend(); toggleActionPanel(true); };
            elements.actionSendSticker.onclick = () => { handleStickerSend(); toggleActionPanel(true); };
            elements.actionVideoCall.onclick = () => { startVideoCall(); toggleActionPanel(true); };
            elements.actionCreatePoll.onclick = () => { openCreatePollModal(); toggleActionPanel(true); };

            elements.fetchModelsBtn.onclick = async () => { const baseUrl = elements.apiBaseUrlInput.value.trim(); const apiKey = elements.apiKeyInput.value.trim(); if (!baseUrl || !apiKey) { alert('APIエンドポイントとAPIキーを入力してください'); return; } elements.fetchModelsBtn.textContent = '取得中...'; elements.fetchModelsBtn.disabled = true; try { const response = await fetch(`${baseUrl}/v1/models`, { headers: { 'Authorization': `Bearer ${apiKey}` } }); if (!response.ok) throw new Error(`モデルリストの取得に失敗しました, Status: ${response.status} ${await response.text()}`); const data = await response.json(); elements.modelSelect.innerHTML = ''; const models = data.data || data; if (!Array.isArray(models)) throw new Error('APIからのモデルリストのフォーマットが正しくありません'); models.sort((a, b) => a.id.localeCompare(b.id)).forEach(model => { if (model.id) elements.modelSelect.add(new Option(model.id, model.id)); }); const currentCharacter = getCurrentCharacter(); if (currentCharacter?.config?.model) { elements.modelSelect.value = currentCharacter.config.model; } } catch (error) { alert(`モデルの取得に失敗: ${error.message}`); } finally { elements.fetchModelsBtn.textContent = 'モデルリスト取得'; elements.fetchModelsBtn.disabled = false; } };
            elements.themeSelector.onclick = (e) => { const t = e.target.closest('.theme-option'); if (t) applyTheme(t.dataset.theme); };
            
            queryEl('label[for="background-upload-input"]').onclick = () => elements.backgroundUploadInput.click();
            elements.backgroundUploadInput.onchange = e => handleFileUpload(e.target.files[0], (d) => { elements.chatContainer.style.backgroundImage = `url(${d})`; });
            queryEl('label[for="ai-avatar-upload-input"]').onclick = () => elements.aiAvatarUploadInput.click();
            elements.aiAvatarUploadInput.onchange = e => handleFileUpload(e.target.files[0], (d) => { elements.aiAvatarPreview.src = d; if(currentChat.type==='direct') elements.headerAvatar.src = d; });
            queryEl('label[for="user-avatar-upload-input"]').onclick = () => elements.userAvatarUploadInput.click();
            elements.userAvatarUploadInput.onchange = e => handleFileUpload(e.target.files[0], (d) => { elements.userAvatarPreview.src = d; });
            queryEl('label[for="user-moments-avatar-upload-input"]').onclick = () => elements.userMomentsAvatarInput.click();
            elements.userMomentsAvatarInput.onchange = e => handleFileUpload(e.target.files[0], d => { elements.userMomentsAvatarPreview.src = d; });
            queryEl('label[for="user-moments-cover-upload-input"]').onclick = () => elements.userMomentsCoverInput.click();
            elements.userMomentsCoverInput.onchange = e => handleFileUpload(e.target.files[0], d => { elements.userMomentsCoverPreview.src = d; });

            elements.manageStickersBtn.onclick = () => openStickerManager('user');
            elements.manageAiStickersBtn.onclick = () => openStickerManager('ai');
            elements.clearHistoryBtn.onclick = clearChatHistory;
            elements.deleteCharacterBtn.onclick = () => { closeModal(elements.settingsModal); handleDeleteChat('direct', currentChat.id); };
            
            elements.exportDataBtn.onclick = exportData;
            elements.importDataBtn.onclick = importData;
            elements.importDataInput.onchange = handleDataImport;
            
            elements.realImageUploadInput.onchange = (e) => handleFileUpload(e.target.files[0], (d) => handleUserAction({ sender:'user', type:'image', imageUrl:d, llmContent:'[アルバムから写真を送信した]' }));
            elements.messageInput.addEventListener('input', autoResizeTextarea);
            elements.featureModalCloseBtn.addEventListener('click', () => closeModal(elements.featureModal));
            elements.featureModalSubmitBtn.addEventListener('click', () => { if (onFeatureModalSubmit) onFeatureModalSubmit(); });
            
            elements.chatManagerBtn.onclick = openChatManager;
            elements.momentsCloseBtn.onclick = () => elements.momentsOverlay.classList.remove('show');
            elements.postNewMomentBtn.onclick = openPostMomentModal;
            elements.momentsFeed.addEventListener('click', handleMomentsInteraction);

            elements.messagesContainer.addEventListener('click', e => {
                const voteBtn = e.target.closest('.poll-vote-btn');
                if (voteBtn && !voteBtn.disabled) {
                    handleUserVote(voteBtn.dataset.pollId, voteBtn.dataset.option);
                }
            });

            window.addEventListener('click', (e) => { 
                if (e.target === elements.settingsModal) closeModal(elements.settingsModal); 
                if (e.target === elements.featureModal) closeModal(elements.featureModal);
                if (e.target === elements.mindVoiceModal) elements.mindVoiceModal.classList.remove('show');
            });
            elements.chatNameHeader.addEventListener('blur', () => { 
                const chatData = getCurrentChatData();
                if(!chatData) return;
                const newName = elements.chatNameHeader.textContent.trim(); 
                const oldName = currentChat.type === 'direct' ? chatData.config.characterName : chatData.name;
                if(newName && newName !== oldName){ 
                    if(currentChat.type === 'direct') {
                        chatData.config.characterName = newName;
                    } else {
                        chatData.name = newName;
                    }
                    saveAllData();
                } else { 
                    elements.chatNameHeader.textContent = oldName; 
                }
            });
            elements.confirmDeleteBtn.onclick = deleteSelectedMessages;
            elements.cancelDeleteBtn.onclick = () => toggleMultiSelectMode(false);
        };

        // --- Initialization ---
        loadAllData();
        setupEventListeners();
        autoResizeTextarea();
    });
    </script>
</body>
</html>